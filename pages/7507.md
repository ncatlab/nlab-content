
+-- {: .rightHandSide}
+-- {: .toc .clickDown tabindex="0"}
### Context
#### Type theory
+-- {: .hide}
[[!include type theory - contents]]
=--
=--
=--

# $\eta$-conversion
* table of contents
{: toc}

## Idea

In [[type theory]], $\eta$-conversion is a process of "computation" which is "dual" to [[beta-conversion]].

Whereas $\beta$-reduction tells us how to simplify a term that involves an *eliminator* applied to a *constructor*, $\eta$-reduction tells us how to simplify a term that involves a *constructor* applied to an *eliminator*.

In contrast to $\beta$-reduction, whose "directionality" is universally agreed upon, the directionality of $\eta$-conversion is not always the same.  Sometimes one may talk about $\eta$-**reduction**, which (usually) simplifies a constructor--eliminator pair by removing it, but we may also talk about $\eta$-**expansion**, which (usually) makes a term more complicated by introducing a constructor--eliminator pair.  Although one might expect that of course we always want to use reduction to simplify, it is possible to put bounds on $\eta$-expansion, and $\eta$-reduction is ill-defined for the [[unit type]] (the exception prompting 'usually' above).

The [[equivalence relation]] generated by $\eta$-reduction/expansion is called $\eta$-**equivalence**, and the whole collection of processes is called $\eta$-**conversion**.


## Examples

### For function types

The most common example is for a [[function type]] $A \to B$.

In this case, the constructor of $A \to B$ is a *$\lambda$-expression*: given a term $b$ of type $B$ containing a free variable $x$ of type $A$, then $\lambda x.b$ is a term of type $A \to B$.

The eliminator of $A \to B$ says that given a term $f$ of type $A \to B$ and a term $a$ of type $A$, we can *apply* $f$ to $a$ to obtain a term $f(a)$ of type $B$.

An $eta$-[[redex]] (a term that can be reduced by $\eta$-reduction) is then of the form $\lambda x.\, f(x)$ -- the constructor (lambda expression) applied to the eliminator (application).  Eta reduction reduces such a redex to the term $f$.

Conversely, $\eta$-expansion expands any bare function term $f$ to the form $\lambda x.\, f(x)$.  If $\eta$-expansion is applied again to this, we get $\lambda x.\, (\lambda y.\, f(y))(x)$, but $\beta$-reduction returns this to $\lambda x.\, f(x)$; therefore, this last form is considered to be fully $\eta$-expanded.  In general, the rule when applying $\eta$-expansion is to use it only when the result is not a $\beta$-redex.


### For product types

Although function types are the most publicized notion of $\eta$-reduction, basically all types in type theory can have a form of it.  For instance, in the [[negative type|negative]] presentation of a [[product type]] $A \times B$, the constructor is an [[ordered pair]] $(a,b)\colon A\times B$, while the eliminators are projections $\pi_1$ and $\pi_2$ which yield elements of $A$ or $B$.

The $\eta$-expansion rule then says that for a term $p\colon A\times B$, the term $(\pi_1 p, \pi_2 p)$ --- the constructor applied to the eliminators --- is equivalent to $p$ itself.  (Again, we do not repeat the $\eta$-expansion, as this would produce a $\beta$-redex.)  If we use $\eta$-reduction instead, then we simplify any subterm of the form $(\pi_1 p, \pi_2 p)$ to $p$ (and leave anything not of that form alone).


### For unit types

Above we did a product type with two factors, although it\'s easy to generalise to any [[natural number]] of factors.  The case with zero factors is known as the [[unit type]], and $\eta$-conversion behaves a bit oddly there; let us examine it.

In the [[negative type|negative]] presentation of the unit type $1$, the constructor is an [[empty list]] $()\colon 1$, while there are no eliminators.  The $\eta$-expansion rule then says that any term $p\colon 1$ is equivalent to the term $()$ --- the constructor applied to no eliminators.  In this case, if we repeat the $\eta$-expansion, this does not produce a $\beta$-redex (indeed, there is *no* $\beta$-reduction for the unit type), but simply makes no change.  If we try to apply $\eta$-reduction to $()$, then this is ill-defined; we could 'simplify' this to *any* term $p\colon 1$ that we might be able to construct.

The [[positive type|positive]] presentation of the unit type does have a well-defined $\eta$-reduction, however; see [[unit type]].


## Implementation

Eta-reduction/expansion is not as well-behaved formally as beta-reduction, and its introduction can make computational equality undecidable.  For this reason and others, it is not always implemented in computer proof assistants.

[[Coq]] versions 8.3 and prior do not implement $\eta$-equivalence (definitionally), but versions 8.4 and higher do implement it for [[dependent product types]] (which include [[function types]]).  Even in Coq v8.4, $\eta$-equivalence is not implemented for other types, such as inductive and coinductive types.  This is a good thing for [[homotopy type theory]], since $\eta$-equivalence for [[identity types]] forces us into [[extensional type theory]].

When $\eta$-equivalence is not an implemented as a direct identity, it may be derived for a defined (coarser than identity) equality.  For example, if $f =_{A \to B} g$ is defined to mean $\forall x.\, f(x) =_B g(x)$ (where $=_B$ is assumed to have been previously defined) and $(\lambda x.\, b)(a)$ is taken to be identical to $b[a/x]$ (implementing $\beta$-reduction), then $f$ and $\lambda x.\, f(x)$ are provably equal even if not identical.  Thus, eta-equivalence for function types follows from [[function extensionality]] (relative to any appropriate notion of equality).

Similarly, if "equality" refers to a Martin-Löf [[identity type]] in [[dependent type theory]], then a suitable form of $\eta$-equivalence is provable for inductively defined types (with $\beta$-reduction and a dependent eliminator).  This includes the identity types themselves, but this form of $\eta$-equivalence does not imply the identity types are extensional because the identity type itself must be incorporated in stating the equivalence.


## Related concepts

* [[lambda-calculus]]

* [[beta-reduction]]


[[!redirects eta conversion]]
[[!redirects eta-conversion]]
[[!redirects η-conversion]]

[[!redirects eta reduction]]
[[!redirects eta-reduction]]
[[!redirects η-reduction]]

[[!redirects eta expansion]]
[[!redirects eta-expansion]]
[[!redirects η-expansion]]

[[!redirects eta equivalent]]
[[!redirects eta-equivalent]]
[[!redirects η-equivalent]]
[[!redirects eta equivalence]]
[[!redirects eta-equivalence]]
[[!redirects η-equivalence]]
