+-- {: .rightHandSide}
+-- {: .toc .clickDown tabindex="0"}
### Context
#### Category theory
+-- {: .hide}
[[!include category theory - contents]]
=--
=--
=--

# Contents
* table of contents
{: toc}

## Definitions

### Abstract definition

\begin{definition}
**Two categories with the same collection of objects with an identity-on-objects functor** is a category $C$ enriched in the [[arrow category]] $Set^I$ of [[Set]]. 
\end{definition}

### By components

First, we distinguish between a [[category]], and a category structure on a [[collection]] of [[objects]], in the same way one does between a [[proset]] and a [[preorder]], the equivalence relation structure on a collection of objects, in (0, 1)-category theory. 

\begin{definition}
A **category structure** on a collection of objects $Ob$ is a family of sets $Mor(x, y)$ whose elements are called morphisms, indexed by objects $x:Ob$ and $y:Ob$, such that

* for each object $x:Ob$, a morphism $\mathrm{id}_x:Mor(x, x)$
* for each object $x:Ob$, $y:Ob$, and $z:Ob$, a function $\circ_{x, y, z}:Mor(y, z) \times Mor(x, y) \to Mor(x, z)$

such that 

* for each object $x:Ob$ and $y:Ob$ and morphism $f:Mor(x, y)$, $f \circ_{x, y, z} \mathrm{id}_x = \mathrm{id}_x$ and $\mathrm{id}_y \circ_{x, y, z} f = \mathrm{id}_y$. 
* for each object $x:Ob$, $y:Ob$, $z:Ob$, $w:Ob$ and morphism $f:Mor(x, y)$, $g:Mor(y, z)$, $h:Mor(z, w)$, 
$$h \circ_{x, z, w} (g \circ_{x, y, z} f) = (h \circ_{y, z, w} g) \circ_{x, y, w} f$$ 

\end{definition}

\begin{definition}
A **category** $C$ is a collection $Ob$ with a category structure $Mor(x, y)$ indexed by objects $x:Ob$ and $y:Ob$. 
\end{definition}

\begin{definition}
**Two categories with the same collection of objects** $A$ and $B$ is a collection $Ob$ with two category structures $Mor_A(x, y)$ and $Mor_B(x, y)$ indexed by objects $x:Ob$ and $y:Ob$. The categories $A$ and $B$ are defined to be $(Ob, Mor_A)$ and $(Ob, Mor_B)$ respectively. 
\end{definition}

\begin{definition}
**An identity-on-objects functor** between two categories with the same collection of objects $A$ and $B$ is a family of functions $F_{Mor}(a, b):Mor_A(a, b) \to Mor_B(a, b)$ which preserve the category structure on the type families:

* [[composition]] of [[morphisms]] is preserved: for all morphisms $f: Mor_A(a, b)$ and $g:Mor_B(b, c)$, $F_{Mor}(g \circ^A f) = F_{Mor}(g) \circ^B F_{Mor}(f)$,

* identity morphisms are preserved: $F_{Mor}(id^A_a) = id^B_a$.
 
\end{definition}

### Historical note

#### Is the identity-on-objects functor a functor?

Historically, the notion of **identity-on-objects functor** in between two categories with the same collection of objects was defined to be an actual functor, additionally having a function on the objects $F_{Ob}:Ob_C \to Ob_C$ which is the [[identity function]] on $Ob_C$. This was where the original name "identity-on-objects functor" comes from. The problem with this definition is twofold: 

* In a [[material set theory]] or [[structural set theory]] or a type theory with [[axiom K]], the above definition violates the [[principle of equivalence]] if one were to use it to define concrete [[dagger categories]] such as [[Rel]], [[Hilb]] or concrete [[groupoids]] such as the [[permutation category]], since in those cases the definition explicitly refers to [[propositional equality]] of [[sets]]. 

* In a [[univalent type theory]], [[identity functions]] do not necessarily violate the [[principle of equivalence]], because the [[identity type]] $id(x) =_Ob x$ for object $x:A$ is not necessarily a proposition, and in the presence of [[univalence]], is necessarily required to satisfy the [[principle of equivalence]]. However, the [[identifications]] $p(x):id(x) =_Ob x$ are additional structure on the mathematical object, and thus does not result in the same object as the definitions above do. 

As a result, the current definition of an identity-on-objects functor, valid in all foundations and respecting the [[principle of equivalence]], was adopted, which doesn't have such an identity function on the objects. However, the name "identity-on-objects functor" then becomes a [[red herring principle|red herring]], since it is not actually a [[functor]] between the two objects collections. 

#### The notion of two categories with the same collection of objects

There are a number of different ways to define two categories with the same collection of objects:

##### With propositional equality or equivalence

In set theory, the objects of a category are required to be a set. In [[material set theories]], one could postulate the condition that $Ob = ob(A) = ob(B)$. However, it mentions equality of sets, which means that the definition is not even definable in a [[structural set theory]] such as [[SEAR]] or [[ETCS with elements]], where there is no notion of equality of sets, only equality of [[functions]], [[relations]], and [[elements]]. In structural set theories, instead of talking about equality of sets, one talks about having [[bijection]] between sets $a:Ob \cong ob(A)$, $b:Ob \cong ob(B)$, and $F_{ob}:ob(A) \cong ob(B)$. This yields a [[bijective-on-objects functor]]. 

In type theories, the objects of a category do not form a set, but a type. The categories whose type of objects is a set is a strict category, and as a result, the above definitions are only valid for [[strict categories]]. However, there is a generalization of both material set theory equality of sets and structural set theory bijection of sets to type theory: identity types and equivalence of types. 

For identity types, one postulates the existence of [[identifications]] $a:Ob =_\mathcal{U} ob(A)$ and $b:Ob =_\mathcal{U} ob(B)$, resulting in an identification $a^{-1} b: ob(A) =_\mathcal{U} ob(B)$. This is what is called an **identity-on-objects functor** in type theory. For equivalences, one postulates the existence of [[equivalence in homotopy type theory|equivalence]] $a:Ob \simeq_\mathcal{U} ob(A)$ and $b:Ob \simeq_\mathcal{U} ob(B)$, and $F_{ob}:ob(A) \simeq_\mathcal{U} ob(B)$. This yields an [[equivalent-on-objects functor]]. If the background universe $\mathcal{U}$ is an [[univalent universe]], then equivalent-on-objects functors and identity-on-objects functors are equivalent to each other. If the categories are strict, then both equivalent-on-objects functors and identity-on-objects functors are equivalent to bijective-on-objects functors. 

However, in general categories, all these definitions still nevertheless violate the [[principle of equivalence]]. What one actually needs are [[essentially surjective functors]]. Only in [[univalent categories]] are essentially surjective functors the same as equivalent-on-object functors, and additionally only when both the source and target univalent categories are in a [[univalent universe]] are essentially surjective functors between univalent categories identity-on-object functors. 

##### With judgmental equality

There is another notion of equality in type theory, [[judgmental equality]], which is a metatheoretic [[judgment]] rather than a [[type]] or [[propositional equality]]. In this case, the underlying object types of the two categories $A$ and $B$ are judgmentally equal, $ob(A) \equiv ob(B)$, and we could similarly judge that they are judgmentally equal to a third type $Ob$, $Ob \equiv ob(A)$ and $Ob \equiv ob(B)$. By the definition of identity function in type theory ($id_{Ob} \coloneqq \lambda x.x:Ob \to Ob$), given an object $x:Ob$, $id_{Ob}(x)$ is judgmentally equal to $x$:
$$\Gamma, x:Ob \vdash id_{Ob}(x) \equiv x:Ob$$
This results in the following definition:

\begin{definition}
An **identity-on-objects [[functor]]** $F: A\to B$ between [[categories]] $A$ and $B$ whose type of [[objects]] are [[judgmental equality|judgmentally equal]] to a third type $Ob$, i.e. $Ob \equiv ob(A)$ and $Ob \equiv ob(B)$, is a functor between categories which has as its underlying object function $F_{ob}: Ob \to Ob$ the [[identity function]] on $Ob$. 
\end{definition}

This definition does not violate the [[principle of equivalence]], because judgmental equality is a judgment, and thus does not result in (propositional) equality of objects. 

This is additionally the same as postulating that there is only one type $Ob$ with two [[type families]] on $Ob$, $A(x,y)$ and $B(x,y)$ for $x,y\in Ob$, with additional composition, identity, associativity, and unital laws for morphisms, making each of $(Ob, A)$ and $(Ob, B)$ into a category, plus a family of functions $A(x,y) \to B(x,y)$ which commuting with these category structures. This is the approach used in two separate definitions of [[dagger categories]] on the nLab. 

More abstractly, this can be defined as a category [[enriched category|enriched]] over the [[arrow category]] $Set^\to$.  See also [[M-category]] and [[F-category]].

## Alternative: using displayed categories

...

## Examples

* A [[dagger category]] is a category $\mathcal{C}$ with a [[contravariant functor|contravariant endofunctor]] $\dagger:\mathcal{C}^\op \to \mathcal{C}$ that is an identity-on-objects functor, such that for all objects $A:\mathcal{C}$ and $B:\mathcal{C}$ and morphisms $f:Hom(A,B)$, $(f^\dagger)^\dagger = f$. 

## Related pages

* [[bijective-on-objects functor]]
* [[equivalent-on-objects functor]]
* [[essentially surjective functor]] 
* [[displayed category]]
* [[Freyd category]]
* [[Freyd multicategory]]
* [[dagger category]]
* [[principle of equivalence]]

## References

For the definition of isomorphism of categories and adjoint equivalence of univalent categories: 

* Univalent Foundations Project, [[HoTT book|Homotopy Type Theory â€“ Univalent Foundations of Mathematics]] (2013)

For the use of [[displayed categories]] instead of [[identity-on-objects functors]] in definitions:

* Benedikt Ahrens, Peter LeFanu Lumsdaine, *Displayed Categories*, ([arXiv:1705.04296](https://arxiv.org/abs/1705.04296))

[[!redirects identity-on-objects]]
[[!redirects identity on objects]]

[[!redirects identity-on-objects functor]]
[[!redirects identity-on-objects functors]]
[[!redirects identity on objects functor]]
[[!redirects identity on objects functors]]
[[!redirects io functor]]
[[!redirects io functors]]
[[!redirects i.o. functor]]
[[!redirects i.o. functors]]
