
+-- {: .rightHandSide}
+-- {: .toc .clickDown tabindex="0"}
### Context
#### Type theory
+-- {: .hide}
[[!include type theory - contents]]
=--
#### Deduction and Induction
+-- {: .hide}
[[!include deduction and induction - contents]]
=--
#### Foundations
+-- {: .hide}
[[!include foundations - contents]]
=--
=--
=--

# Contents
* table of contents
{: toc}

## Idea
 {#Idea}

In [[mathematics]] and specifically in [[formal logic]], by a "list" one means the fairly evident formalization of the colloquial notion of a "list of elements": 

If a [[set]] $E$ of admissible elements is given --- also called an  "[[alphabet]]", in this context --- then a list of $E$-elements is a [[tuple]] $(e_1, e_2, \cdots, e_\ell)$ of elements $e_i \,\in\, E$, of any length $\ell \,\in\, \mathbb{N}$ --- also called a *[[word]]* in the given alphabet.

Typically one will write "$List(E)$" or similar for the [[set]] of all lists with entries in $E$.

For instance, for $E$ the ([[underlying]] set of) a [[field]], the component-expressions of [[vectors]] in the [[vector space]] $k^n$ may be thought of as lists of length $n$ with elements in $k$. However, doing so means to disregard the [[vector space]]-[[structure]] on the collection of all such lists.

Instead, the notion of *list* is a [[concept with an attitude]]: While lists are just [[tuples]] of any length, calling them lists indicates that one intends to consider the operation of *[[concatenation]]* of lists to larger lists, in particular the operations of appending an element to a list.

It is evident that the operation of concatenation makes $List(E)$ a *[[monoid]]* (the [[neutral element]] under concatenation is the [[empty list]], i.e. the unique list of length [[zero]]). In fact, a moment of reflection shows that, as such, $\big(List(E), conc\big)$ is the *[[free monoid]]* on $E$.

Therefore, in much of the mathematical literature, lists are understood as [[free monoids]].


Specifically in [[computer science]] one commonly deals with the corresponding notion of the [[data type]] of lists (with entries in a prescribed data type), which serve as a basic and common kind of [[data structure]]. In [[programming languages]] supporting something like a [[calculus of constructions]], this [[data type]], essentially with the [[free monoid]]-[[structure]] as above, may be defined as an  *[[inductive type]]* in an evident way (made explicit [below](#Definition)).

On the other hand, in [[dependent type theories]] which have a [[homotopy type theory]]-interpretation --- in that they do not verify [[uniqueness of identity proofs]] (or "[[axiom K (type theory)|axiom K]]") --- one may want to distinguish between lists and [[free monoids]]: 

Because, in such theories it may happen that the given [[alphabet]] [[type]] $E$ is not actually a [[set]] but a higher [[homotopy type]], in that it is not [[0-truncated]]. In this case it still makes good sense to speak of *lists* of elements ([[terms]]) of $E$, only that now the corresponding [[type]] $List(E)$ is itself not [[0-truncated]].  But since the term "[[monoid]]" carries with it a connotation of being [[0-truncated]], one may no longer want to call this the *[[free monoid]]* on $E$. It is, of course, still a free monoid in the proper [[higher algebra|higher algebraic]] sense (cf. *[[monoid in a monoidal (infinity,1)-category|monoid in a monoidal $\infty$-category]]*).


## Definition
 {#Definition}

The type of lists on a type $A$ is defined as the [[dependent sum type]]

$$\mathrm{List}(A) \coloneqq \sum_{n:\mathbb{N}} \mathrm{Fin}(n) \to A$$

where $\mathrm{Fin}(n)$ is the [[finite set]] with $n$ elements. This shows that lists are just [[tuples]]. 

### Rules for types of lists

Assuming that [[identification types]], [[function types]] and [[dependent product types]] exist in the type theory, the type of lists on a type $A$ of [[generators]] is the [[inductive type]] $\mathrm{List}(A)$ generated by an element $\mathrm{nil}:\mathrm{List}(A)$ and a function $\mathrm{cons}:A \to \mathrm{List}(A) \to \mathrm{List}(A)$:

Formation rules for the type of lists:
$$\frac{\Gamma \vdash A \; \mathrm{type}}{\Gamma \vdash \mathrm{List}(A) \; \mathrm{type}}$$

Introduction rules for the type of lists:
$$\frac{\Gamma \vdash A \; \mathrm{type}}{\Gamma \vdash \mathrm{nil}:\mathrm{List}(A)} \qquad \frac{\Gamma \vdash A \; \mathrm{type}}{\Gamma \vdash \mathrm{cons}:A \to (\mathrm{List}(A) \to \mathrm{List}(A))}$$

Elimination rules for the type of lists:
$$\frac{
    \begin{array}{l}
      \Gamma \vdash A \; \mathrm{type} \quad \Gamma, x:\mathrm{List}(A) \vdash C(x) \; \mathrm{type} \\
      \Gamma \vdash c_\mathrm{nil}:C(\mathrm{nil}) \quad \Gamma \vdash c_\mathrm{cons}:\prod_{a:A} \prod_{x:\mathrm{List}(A))} C(x) \to C(\mathrm{cons}(a)(x)) \\
      \Gamma \vdash g:\mathrm{List}(A))
    \end{array}
  }{\Gamma \vdash \mathrm{ind}_{\mathrm{List}(A)}^C(c_\mathrm{nil}, c_\mathrm{cons}, g):C(g)}$$

Computation rules for the type of lists:

* Judgmental computation rules

$$\frac{
    \begin{array}{l}
      \Gamma \vdash A \; \mathrm{type} \quad \Gamma, x:\mathrm{List}(A) \vdash C(x) \; \mathrm{type} \\
      \Gamma \vdash c_\mathrm{nil}:C(\mathrm{nil}) \quad \Gamma \vdash c_\mathrm{cons}:\prod_{a:A} \prod_{x:\mathrm{List}(A))} C(x) \to C(\mathrm{cons}(a)(x))
    \end{array}
  }{\Gamma \vdash \mathrm{ind}_{\mathrm{List}(A)}^C(c_\mathrm{nil}, c_\mathrm{cons}, \mathrm{nil}) \equiv c_\mathrm{nil}:C(\mathrm{nil})}$$

\linebreak

$$\frac{
    \begin{array}{l}
      \Gamma \vdash A \; \mathrm{type} \quad \Gamma, x:\mathrm{List}(A) \vdash C(x) \; \mathrm{type} \\
      \Gamma \vdash c_\mathrm{nil}:C(\mathrm{nil}) \quad \Gamma \vdash c_\mathrm{cons}:\prod_{a:A} \prod_{x:\mathrm{List}(A))} C(x) \to C(\mathrm{cons}(a)(x)) \\
      \Gamma \vdash b:A \quad \Gamma \vdash g:\mathrm{List}(A))
    \end{array}
  }{\Gamma \vdash \mathrm{ind}_{\mathrm{List}(A)}^C(c_\mathrm{nil}, c_\mathrm{cons}, \mathrm{cons}(b)(g)) \equiv c_\mathrm{cons}(b)(g)(\mathrm{ind}_{\mathrm{List}(A)}^C(c_\mathrm{nil}, c_\mathrm{cons}, g)):C(\mathrm{cons}(b)(g))}$$

\linebreak

* Typal computation rules

$$\frac{
    \begin{array}{l}
      \Gamma \vdash A \; \mathrm{type} \quad \Gamma, x:\mathrm{List}(A) \vdash C(x) \; \mathrm{type} \\
      \Gamma \vdash c_\mathrm{nil}:C(\mathrm{nil}) \quad \Gamma \vdash c_\mathrm{cons}:\prod_{a:A} \prod_{x:\mathrm{List}(A))} C(x) \to C(\mathrm{cons}(a)(x))
    \end{array}
  }{\Gamma \vdash \beta_{\mathrm{List}(A)}^\mathrm{nil}(c_\mathrm{nil}, c_\mathrm{cons}):\mathrm{Id}_{C(\mathrm{nil})}(\mathrm{ind}_{\mathrm{List}(A)}^C(c_\mathrm{nil}, c_\mathrm{cons}, \mathrm{nil}), c_\mathrm{nil})}$$

\linebreak

$$\frac{
    \begin{array}{l}
      \Gamma \vdash A \; \mathrm{type} \quad \Gamma, x:\mathrm{List}(A) \vdash C(x) \; \mathrm{type} \\
      \Gamma \vdash c_\mathrm{nil}:C(\mathrm{nil}) \quad \Gamma \vdash c_\mathrm{cons}:\prod_{a:A} \prod_{x:\mathrm{List}(A))} C(x) \to C(\mathrm{cons}(a)(x)) \\
      \Gamma \vdash b:A \quad \Gamma \vdash g:\mathrm{List}(A))
    \end{array}
  }{\Gamma \vdash \beta_{\mathrm{List}(A)}^\mathrm{cons}(c_\mathrm{nil}, c_\mathrm{cons}, b, g):\mathrm{Id}_{C(\mathrm{cons}(b)(g))}(\mathrm{ind}_{\mathrm{List}(A)}^C(c_\mathrm{nil}, c_\mathrm{cons}, \mathrm{cons}(b)(g)), c_\mathrm{cons}(b)(g)(\mathrm{ind}_{\mathrm{List}(A)}^C(c_\mathrm{nil}, c_\mathrm{cons}, g)))}$$

\linebreak

Uniqueness rules for the type of lists:

* Judgmental uniqueness rules

$$\frac{\Gamma \vdash A \; \mathrm{type} \quad \Gamma, x:\mathrm{List}(A) \vdash C(x) \; \mathrm{type} \quad \Gamma \vdash c:\prod_{x:\mathrm{List}(A)} C(x) \quad \Gamma \vdash g:\mathrm{List}(A)}{\Gamma \vdash \mathrm{ind}_{\mathrm{List}(A)}^C(c(\mathrm{nil}), \lambda a:A.\lambda x:\mathrm{List}(A).c(\mathrm{cons}(a)(x)), g) \equiv c(g):C(g)}$$

* Typal uniqueness rules

$$\frac{\Gamma \vdash A \; \mathrm{type} \quad \Gamma, x:\mathrm{List}(A) \vdash C(x) \; \mathrm{type} \quad \Gamma \vdash c:\prod_{x:\mathrm{List}(A)} C(x) \quad \Gamma \vdash g:\mathrm{List}(A)}{\Gamma \vdash \eta_{\mathrm{List}(A)}(c, n):\mathrm{Id}_{C(g)}(\mathrm{ind}_{\mathrm{List}(A)}^C(c(\mathrm{nil}), \lambda a:A.\lambda x:\mathrm{List}(A).c(\mathrm{cons}(a)(x)), g), c(g))}$$

The elimination, typal computation, and typal uniqueness rules for the type of lists type state that the type of lists satisfy the **dependent universal property of the type of lists**. If the dependent type theory also has [[dependent sum types]] and [[product types]], allowing one to define the [[uniqueness quantifier]], the dependent universal property of the type of lists could be simplified to the following rule:

$$\frac{\Gamma \vdash A \; \mathrm{type} \quad \Gamma, x:\mathrm{List}(A) \vdash C(x) \; \mathrm{type} \quad \Gamma \vdash c_\mathrm{nil}:C(\mathrm{nil}) \quad \Gamma \vdash c_\mathrm{cons}:\prod_{a:A} \prod_{x:\mathrm{List}(A))} C(x) \to C(\mathrm{cons}(a)(x))}{\Gamma \vdash \mathrm{up}_\mathbb{Z}^C(c_\mathrm{nil}, c_\mathrm{cons}):\exists!c:\prod_{x:\mathrm{List}(A))} C(x).\mathrm{Id}_{C(\mathrm{nil})}(c(\mathrm{nil}), c_\mathrm{nil}) \times \prod_{a:A} \prod_{x:\mathrm{List}(A)} \mathrm{Id}_{C(\mathrm{cons}(a)(x))}(c(\mathrm{cons}(a)(x)), c_\mathrm{cons}(a)(c(x)))}$$

## See also

* [[natural numbers type]] (the list on the unit type $\mathrm{List}(\mathbb{1})$)

* [[underlying type of free infinity-group]] (the invertible version of the type of lists)

## References

Types of lists are defined in section 5.1 in:

* *Homotopy Type Theory: Univalent Foundations of Mathematics*, The [[Univalent Foundations Project]], Institute for Advanced Study, 2013. ([web](http://homotopytypetheory.org/book/), [pdf](http://hottheory.files.wordpress.com/2013/03/hott-online-323-g28e4374.pdf))

[[!redirects list]]
[[!redirects lists]]

[[!redirects type of lists]]
[[!redirects types of lists]]

[[!redirects universal property of the type of lists]]
[[!redirects dependent universal property of the type of lists]]

[[!redirects cons]]