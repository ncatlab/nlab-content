
From a broad perspective, all quantum gates are linear maps, hence
functions between tensor types.

On a finer level, some such (families of) linear maps are more readily
implemented on given physical hardware than others.

Existing quantum programming languages tend to have little reflection
of this more detailed information, they are not "hardware aware". What
we are thinking about is a language which has dependent linear types
just as Quipper does, but in addition has infrastructure to naturally
speak about that particular class of these which matches expected TQC
hardware functionality.

Concretely, the elementary quantum gates that are expected to be
realized by a topological quantum computer are of a very specific and
peculiar kind: They are families of linear maps which are
parameterized by elements of a braid group and which constitute a
specific class of linear representations of the braid group, namely
"monodromy braid representations on su(2)-conformal blocks".

Quipper has no information about this. If one were to run (in the
future) a Quipper program on a topological quantum computer, there
would have to be a compiler involved which provides this missing
information: It would read in functions between tensor types specified
in Quipper, and would try to approximate them as composites of linear
operators appearing in a monodromy braid representation on
su(2)-conformal blocks.

As a result, the generic Quipper program would tend to have an
inefficient compilation to any given TQC machine. It would not be
"aware" that this is the hardware that it is running on.

The TED-K language scheme that we are describing would be adding to
the expressiveness of a language like Quipper the information about
the native quantum gates that the TQC hardware would provide. The
programmer would be provided with one very particular dependent linear
homotopy type (the fiberwise TED-K type of fibrations of shapes of
config spaces) and would be guaranteed that the linear maps (functions
between tensor types) which are obtained by type transport in/on this
specific dependent linear type are those which the TQC hardware has an
efficient implementation of.

Of course, one could imagine adding this hardware-information by brute
force to Quipper: One could write a Quipper library which encodes by
hand the tensor functions which arise in su(2)-monodromy braid
representations. The programmer could then decide to prefer composites
of these pre-defined linear maps to build their quantum circuits, much
like a contemporary high-level language programmer might choose to
insert fine-tuned "assembler" commands for guarantee of verbatim
efficient implementation on the underlying hardware.

However, in both cases this would be a hack: the assembler code is
alien to the ambient high-level language that calls it, just as
Quipper would not provide any language handle on what it is that a
would-be TQC library is providing.

Our observation is that in homotopy type theory supporting a minimum
of cohesion, this "TQC assembler code library", if you wish, would
automatically and natively be available, constructed "simply" as the
0-truncation of a certain dependent function type whose semantics is
that os certain TED K-theory groups.

This seems like a remarkable confluence of language and physics for
TQC. In the companion note "Anyonic topological order in TED-K" we
explain that these TED-K types are a remarkably accurate reflection
not just of topological quantum gates as such, but generally of the
"topological phases of quantum materials" which are expected to serve
as hardware implementing such gates. With a language for TED-K in
cohesive HoTT, the distinction between a quantum programming language
and an actual simulation of the underlying hardware at just the right
"universal" level of resolution would seem to disappear.
