> [[Kourouklides]]

### Personal notes - please ignore


## Syntax

Depending on the given specifications and desiderata, multiple methods exist for synthesizing a simple type theory along with its associated type language. A minimal construction of a _core [[syntax]]_ is presented below to illustrate such a synthesis.

The core syntax of a simple type theory can be extended to construct other simple type theories, such as [[intuitionistic logic|intuitionistic]] [[higher-order logic]] (intuitionistic simple type theory) and [[classical logic|classical]] higher-order logic (such as "_Church’s type theory_" or _other variants_).


### Grammar

The [[grammar]] of a specific type theory defines how [[terms]] and [[types]] are inductively generated.

Assuming a suitably defined [[alphabet]], the _terms_ of the theory can be generated by the following context-free grammar

$$
  t, u ::= x | \lambda x:A. t | t u
$$

its _types_ can be generated by

$$
  A, B ::= i | o | A \to B
$$

its [[context|contexts]] can be generated by

$$
  \Gamma ::= \emptyset | \Gamma, x : A
$$

and its [[judgment]] forms can be generated by

$$
  \Gamma \vdash t : A
$$

where

* $t, u$ range over terms;
* $x$ ranges over term variables;
* $A, B$ range over types;
* $i$ (individuals) and $o$ (propositions) are base types;
* $\Gamma$ is a context (finite sequence of variable-type bindings);
* $\lambda$ is the abstraction operator (term constructor), binding term variable $x$ of type $A$ in body term $t$.

In a minimal simple type theory, type equality is identified with syntactic equality, so no separate type-equality judgment ($\Gamma \vdash A \equiv B$) is required. Product types (such as $A \times B$) and additional base types can be added explicitly by extending the grammar of types and terms, without altering the _non-dependent_ [[lambda-calculus]] core of the [[deductive system]].

### Rules of the system

Rules of the system define _all the rules_ of a specific type theory and they are a fundamental part of the [[syntax|syntactical]] implementation of a type theory. 

#### Type formation

In a simple type theory, the [[type formation]] rule can be defined _context-free_ as

$$
  \frac{A \colon Type \qquad B \colon Type}
  {A \to B \colon Type}.
$$

In other words, if $A$ and $B$ are types, then $A \to B$ is a type.

#### Variable

The [[type theory#structural_rules|variable or structural]] rule can be defined as

$$
  \frac{x : A \in \Gamma}
  {\Gamma \vdash x : A}.
$$

This rule allows any variable declared in the context to be used as a term of its assigned type.

#### Term introduction

The [[term introduction]] rule can be defined as

$$
  \frac{\Gamma, x : A \vdash t : B}
  {\Gamma \vdash \lambda x : A.\, t : A \to B}.
$$

This rule allows the construction of a function term of type $A \to B$ from a term $t$ of type $B$ that may depend on an input variable $x:A$.

#### Term elimination

The application rule ([[term elimination]] rule) can be defined as

$$
  \frac{\Gamma \vdash f : A \to B \qquad \Gamma \vdash a : A}
  {\Gamma \vdash f\, a : B}.
$$

This rule permits applying a function $f$ of type $A \to B$ to an argument $a$ of type $A$, yielding a term of type $B$.

#### Computation

The [[beta-reduction]] ([[computation rule]]) can be defined as

$$
  (\lambda x : A.\, t)\, u \;\longrightarrow\; t[u/x].
$$

This $\beta$-reduction expresses that applying a function $\lambda x : A.\, t$ to an argument $u$ reduces to the term $t$ with every occurrence of $x$ replaced by $u$.

## Semantics

(...)

===

## Definitions

### Cocategory

Let $A$ be a [[category]] with [[pullbacks]]. A __cocategory__ $C$ is a category object [[internal category|internal to]] category $A^{op}$, consisting of:

* an [[object]] _of [[objects]]_ $C_0 \in A$;

* an [[object]] _of [[morphisms]] $C_1 \in A$;

* structure morphisms:
   *  cosource and cotarget morphisms $s,t: C_0 \to C_1$;

   *  counit $\varepsilon : C_1 \to C_0$;

   *  cocomposition (comultiplication) morphism $\Delta : C_1 \to C_1 \sqcup_{C_0} C_1$;

*  such that the following properties are satisfied, expressing the usual category laws: 
   *  coassociativity law: $(\Delta \sqcup \mathrm{id}) \circ \Delta \;=\;
 (\mathrm{id} \sqcup \Delta) \circ \Delta \;:\; C_1 \longrightarrow C_1 \sqcup_{C_0} C_1 \sqcup_{C_0} C_1$,
where the two iterated [[pushouts]] are identified via the canonical [[associativity]] isomorphism;
   *  counitality law: $(\varepsilon \sqcup \mathrm{id}) \circ \Delta = \mathrm{id}_{C_1} = (\mathrm{id} \sqcup \varepsilon) \circ \Delta.$


### Cocomposition

#### In a plain cocategory


__Cocomposition__ (or _comultiplication_) is the operation that takes a [[morphism]] $f\colon  x \to z$ ​ in a cocategory $C$ and produces a pair of composable morphisms $(f_1,  f_2)$ with

$$
  f_{1} \colon  x \to y  \quad \text{and}  \quad f_{2} \colon  y \to z
$$

represented collectively as a morphism $\Delta(f) \in C_1 \sqcup_{C_0} C_1$ called the __cocomposite__ of $f$.

Intuitively, a single arrow is "split" into two arrows, [[duality|dually]] to the [[composition]] morphism $c: C_1 \times_{C_0} C_1 \to C_1$ that "merges" two arrows into one.

#### In an enriched cocategory

In [[enriched category theory]], for $V$ a [[monoidal category]] the cocomposition operation on a $V$-[[enriched category]] $C$ is, for each 3-tuple $(x,y,z)$ of [[objects]] of $C$, a [[morphism]]

$$
  \Delta_{x,y,z} : C(x,z) \to C(x,y) \otimes C(y,z)
$$


in $V$.

This reduces to the above definition in the case that $V =$ [[Set]]. The cocomposition morphism $\Delta_{x,y,z}$ sends any morphism to a pair of composable morphisms

$$
  \Delta_{x,y,z} : (x \stackrel{f}{\to} z) \;\; \mapsto \;\; \bigl( (x \stackrel{f_1}{\to} y), (y \stackrel{f_2}{\to} z) \bigr).
$$


### Cocategorical semantics

In the context of [[formal logic]], particularly in [[linear logic]] and [[type theories]] with costructural rules, cocomposition is the [[categorical semantics|cocategorical semantics]] for the [[contraction rule]], realized categorically as [[monoidal category with diagonals|diagonal (comultiplicative) maps]] on objects or morphisms.

===



