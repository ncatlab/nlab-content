
+-- {: .rightHandSide}
+-- {: .toc .clickDown tabindex="0"}
### Context
#### Type theory
+-- {: .hide}
[[!include type theory - contents]]
=--
=--
=--

# Contents
* table of contents
{: toc}

## Idea

In [[type theory]] a _sum type_ of two [[types]] $A$ and $B$ (really: [[coproduct]]) is the type whose [[terms]] are either terms $a\colon A$ or terms $b\colon B$.

In a [[model]] of the type theory in [[categorical semantics]] this is a [[distributive coproduct]]. In [[set theory]], it is a [[disjoint union]].

## Definition

Like all type constructors in type theory, to characterize sum types we must specify how to build them, how to construct elements of them, how to use such elements, and the computation rules.

The way to build sum types is easy:

$$ \frac{A\colon Type \qquad B\colon Type}{A+B \colon Type} $$

### As a positive type

Sum types are most naturally presented as [[positive types]], so that the constructor rules are primary.  These say that we can obtain an element of $A+B$ from an element of $A$, or from an element of $B$.

$$ \frac{a\colon A}{inl(a)\colon A+B} \qquad \frac{b\colon B}{inr(b)\colon A+B} $$

The eliminator is derived from these: it says that in order to use an element of $A+B$, it suffices to specify what should be done for the two ways in which that element could have been constructed.

$$ \frac{p\colon A+B \qquad x\colon A\vdash c_A\colon C \qquad y\colon B \vdash c_B\colon C}{match(p, x.c_A, y.c_B) \colon C}$$

The terms $c_A$ and $c_B$ can have [[free variables]] $x$ and $y$ respectively, but those variables become bound in the $match$ expression.  In [[dependent type theory]], we must generalize the eliminator to allow $C$ to depend on $A+B$.

The [[beta reduction]] rules for a constructor followed by an eliminator:

$$
\begin{aligned}
  match(inl(a), x.c_A, y.c_B) &\to_\beta c_A[a/x]\\
  match(inr(b), x.c_A, y.c_B) &\to_\beta c_B[b/y]
\end{aligned}
$$

The [[eta reduction]] rule for the opposite composite says that for any term $c\colon C$ in the context of $p\colon A+B$,

$$match(p, x.c[inl(x)/z], y.c[inr(y)/z]) \to_\eta c[p/z].$$

This says that if we unpack a term of type $A+B$, but only use the resulting term of type $A$ or $B$ by way of packing them back into $A+B$, then we might as well not have unpacked them to begin with.  Note that choosing $C\coloneqq A+B$ and $c \coloneqq z$, we obtain a simpler form of $\eta$-conversion:

$$match(p, x.inl(x), y.inr(y)) \to_\eta p.$$

The positive presentation of sum types can be regarded as a particular sort of [[inductive type]].  In [[Coq]] syntax:

    Inductive sum (A B:Type) : Type :=
    | inl : A -> sum A B
    | inr : B -> sum A B.

Coq implements the beta reduction rule, but not the eta (although eta equivalence is provable for the inductively defined [[identity types]], using the dependent eliminator mentioned above).


### As a negative type

It is possible to present sum types as [[negative types]] as well, but only if we allow [[sequents]] with multiple conclusions.  This is common in [[sequent calculus]] presentations of [[classical logic]], but not as common in type theory and almost unheard of in [[dependent type theory]].

The two definitions are provably equivalent, but only using the [[contraction rule]] and the [[weakening rule]].  Thus, in [[linear logic]] they become distinct; the positive sum type is "plus" $A\oplus B$ and the negative one is "par" $A \parr B$.

### With typal computation and uniqueness rules

Assuming that [[identification types]], [[function types]] and [[dependent product types]] exist in the type theory, the sum type of types $A$ and $B$ is the [[inductive type]] generated by a [[function]] from $A$ to $A + B$ and a function from $B$ to $A + B$:

Formation rules for sum types:
$$\frac{\Gamma \vdash A \; \mathrm{type} \quad \Gamma \vdash B \; \mathrm{type}}{\Gamma \vdash A + B \; \mathrm{type}}$$

Introduction rules for sum types:
$$\frac{\Gamma \vdash A \; \mathrm{type} \quad \Gamma \vdash B \; \mathrm{type}}{\Gamma \vdash \mathrm{in}_A:A \to A + B} \qquad \frac{\Gamma \vdash A \; \mathrm{type} \quad \Gamma \vdash B \; \mathrm{type}}{\Gamma \vdash \mathrm{in}_B:B \to A + B}$$

Elimination rules for sum types:
$$\frac{\Gamma \vdash A \; \mathrm{type} \quad \Gamma \vdash B \; \mathrm{type} \quad \Gamma, x:A + B \vdash C(x) \; \mathrm{type} \quad \Gamma \vdash c_{\mathrm{in}_A}:\prod_{x:A} C(\mathrm{in}_A(x)) \quad \Gamma \vdash c_{\mathrm{in}_B}:\prod_{y:B} C(\mathrm{in}_B(y)) \quad \Gamma \vdash z:A + B}{\Gamma \vdash \mathrm{ind}_{A + B}^C(c_{\mathrm{in}_A}, c_{\mathrm{in}_B}, z):C(y)}$$

Computation rules for sum types:
$$\frac{\Gamma \vdash A \; \mathrm{type} \quad \Gamma \vdash B \; \mathrm{type} \quad \Gamma, x:A + B \vdash C(x) \; \mathrm{type} \quad \Gamma \vdash c_{\mathrm{in}_A}:\prod_{x:A} C(\mathrm{in}_A(x)) \quad \Gamma \vdash c_{\mathrm{in}_B}:\prod_{y:B} C(\mathrm{in}_B(y)) \quad \Gamma \vdash a:A}{\Gamma \vdash \beta_{A + B}^{\mathrm{in}_A}(c_{\mathrm{in}_A}, c_{\mathrm{in}_B}, a):\mathrm{Id}_{C(\mathrm{in}_A(a))}(\mathrm{ind}_{A + B}^C(c_{\mathrm{in}_A}, c_{\mathrm{in}_B}, \mathrm{in}_A(a)), c(a))}$$
$$\frac{\Gamma \vdash A \; \mathrm{type} \quad \Gamma \vdash B \; \mathrm{type} \quad \Gamma, x:A + B \vdash C(x) \; \mathrm{type} \quad \Gamma \vdash c_{\mathrm{in}_A}:\prod_{x:A} C(\mathrm{in}_A(x)) \quad \Gamma \vdash c_{\mathrm{in}_B}:\prod_{y:B} C(\mathrm{in}_B(y)) \quad \Gamma \vdash b:B}{\Gamma \vdash \beta_{A + B}^{\mathrm{in}_B}(c_{\mathrm{in}_A}, c_{\mathrm{in}_B}, b):\mathrm{Id}_{C(\mathrm{in}_B(b))}(\mathrm{ind}_{A + B}^C(c_{\mathrm{in}_A}, c_{\mathrm{in}_B}, \mathrm{in}_B(b)), c(b))}$$

Uniqueness rules for sum types:
$$\frac{\Gamma \vdash A \; \mathrm{type} \quad \Gamma \vdash B \; \mathrm{type} \quad \Gamma, x:A + B \vdash C(x) \; \mathrm{type} \quad \Gamma \vdash c:\prod_{x:A + B} C(x) \quad \Gamma \vdash z:A + B}{\Gamma \vdash \eta_{A + B}(c, z):\mathrm{Id}_{C(z)}(\mathrm{ind}_{A + B}^C(\lambda x:A.c(\mathrm{in}_A(x)), \lambda y:B.c(\mathrm{in}_B(y)), z), c(z))}$$

The elimination, computation, and uniqueness rules for the sum type of $A$ and $B$ state that the sum type of $A$ and $B$ satisfy the **dependent universal property of the sum type** of $A$ and $B$. If the dependent type theory also has [[dependent sum types]] and [[product types]], allowing one to define the [[uniqueness quantifier]], the dependent universal property of the sum type of of $A$ and $B$ could be simplified to the following rule:

$$\frac{\Gamma \vdash A \; \mathrm{type} \quad \Gamma \vdash B \; \mathrm{type} \quad \Gamma, x:A + B \vdash C(x) \; \mathrm{type} \quad \Gamma \vdash c_{\mathrm{in}_A}:\prod_{x:A} C(\mathrm{in}_A(x)) \quad \Gamma \vdash c_{\mathrm{in}_B}:\prod_{y:B} C(\mathrm{in}_B(y))}{\Gamma \vdash \mathrm{up}_{A + B}^C(c_{\mathrm{in}_A}, c_{\mathrm{in}_B}):\exists!c:\prod_{x:A + B} C(x).\left(\prod_{a:A} \mathrm{Id}_{C(\mathrm{in}_A(a))}(c(\mathrm{in}_A(a)), c_{\mathrm{in}_A}(a))\right) \times \left(\prod_{b:B} \mathrm{Id}_{C(\mathrm{in}_B(b))}(c(\mathrm{in}_B(b)), c_{\mathrm{in}_B}(b))\right)}$$

### In terms of dependent sum types and booleans

The sum type can be defined in terms of the [[type of booleans]] and the [[dependent sum type]]. Given types $A$ and $B$, the sum type $A + B$ is defined as 

$$A + B \coloneqq \sum_{x:\mathrm{Bool}} ((x =_\mathrm{Bool} 1) \to A) \times ((x =_\mathrm{Bool} 0) \to B)$$

## Properties

### Descent and large elimination

The [[descent]] for the sum type $A + B$ states that given any type families $x:A \vdash C(x)$ and $y:B \vdash D(y)$ one can construct a type family $z:A + B \vdash \mathrm{descFam}_{A + B}^{C, D}(z)$ with families of [[equivalences of types]] 
$$x:A \vdash \mathrm{descEquiv}_{A + B}^C:\mathrm{descFam}_{A + B}^{C, D}(\mathrm{inl}(x)) \simeq C(x)$$
$$y:B \vdash \mathrm{descEquiv}_{A + B}^D:\mathrm{descFam}_{A + B}^{C, D}(\mathrm{inr}(y)) \simeq D(y)$$ 
Large elimination for sum types strengthens the equivalences of types in descent to [[judgmental equality of types]] 
$$x:A \vdash \mathrm{descFam}_{A + B}^{C, D}(\mathrm{inl}(x)) \equiv C(x) \; \mathrm{type}$$
$$y:B \vdash \mathrm{descFam}_{A + B}^{C, D}(\mathrm{inr}(y)) \equiv D(y) \; \mathrm{type}$$ 

## Related concepts

* [[copy]]

* [[product type]]

* [[dependent sum type]]

## References

A textbook account in the context of [[programming languages]] is in section 12 of 

* [[Robert Harper]], _[[Practical Foundations for Programming Languages]]_

For sum types in [[homotopy type theory]], see:

* *Homotopy Type Theory: Univalent Foundations of Mathematics*, The [[Univalent Foundations Project]], Institute for Advanced Study, 2013. ([web](http://homotopytypetheory.org/book/), [pdf](http://hottheory.files.wordpress.com/2013/03/hott-online-323-g28e4374.pdf))

* [[Egbert Rijke]], *[[Introduction to Homotopy Type Theory]]*, Cambridge Studies in Advanced Mathematics, Cambridge University Press ([arXiv:2212.11082](https://arxiv.org/abs/2212.11082))

[[!redirects sum type]]
[[!redirects sum types]]

[[!redirects descent of the sum type]]
[[!redirects descent of the sum types]]

[[!redirects descent of sum types]]
[[!redirects descent of sum types]]

[[!redirects descent for the sum type]]
[[!redirects descent for the sum types]]

[[!redirects descent for sum types]]
[[!redirects descent for sum types]]

[[!redirects universal property of the sum type]]
[[!redirects universal property of the sum types]]

[[!redirects universal property of sum type]]
[[!redirects universal property of sum types]]

[[!redirects dependent universal property of the sum type]]
[[!redirects dependent universal property of the sum types]]

[[!redirects dependent universal property of sum type]]
[[!redirects dependent universal property of sum types]]

[[!redirects disjoint union type]]
[[!redirects disjoint union types]]
[[!redirects coproduct type]]
[[!redirects coproduct types]]


