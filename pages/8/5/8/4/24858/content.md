
+-- {: .rightHandSide}
+-- {: .toc .clickDown tabindex="0"}
### Context
#### Type theory
+-- {: .hide}
[[!include type theory - contents]]
=--
#### Equality and Equivalence
+--{: .hide}
[[!include equality and equivalence - contents]]
=--
=--
=--

\tableofcontents

## Idea

In [[logic]] and [[type theory]], definitional equality is the metatheoretic [[equivalence relation]] on syntactic expressions ([[types]], [[terms]], [[propositions]], [[contexts]], whatever) which states that two syntactic expressions are equivalent if they have the same meaning. Thus, definitional equality encompasses both [[syntactic equality]] and [[alpha-equivalence]], as well as equivalence of abbreviations and so forth. 

According to [PML (1980), p. 31](#PML):

> Definitional equality is intensional equality, or equality of meaning (synonymy). [...] It is a relation between linguistic expressions [...] Definitional equality is the equivalence relation generated by abbreviatory definitions, changes of [[bound variables]] and the [[principle of substituting equals for equals]]. [...] Definitional equality can be used to rewrite expressions [...].

on p. 60:

> ... intensional (sameness of meaning) ...

Definitional equality is commonly written as $\equiv$, and is used to define certain symbols, abbreviations, and syntactical expressions as other syntactical expressions. For example, one might want to define the symbol $2$ as the syntactical expression $s(s(0))$ representing the successor of the successor of zero in the natural numbers; definitional equality makes it so that in the metatheory, $2 \equiv s(s(0))$. 

In addition, definitions are made using the [[single assignment operator]] $\coloneqq$ in the metatheory, so one would write $2 \coloneqq s(s(0))$. 

## Internalizing definitional equality

Even though definitional equality is defined on general syntactic expressions in the metatheory, for specific syntactic expressions, such as those for [[types]] and [[terms]], it is possible to internalize the notion of definitional equality inside of the object theory itself. This is formalized by the use of [[equality]] with another term or type. 

More specifically, every definition of a symbol $A$ comes with a **formation rule** for the symbol which states that it is a type or an **introduction rule** for the symbol which states that it is a term of a type, and a **[[definition rule]]** that the term or type $A$ is equal to some existing term or type $B$. The equality used in the definition rule is the internal definitional equality of the theory. 

As documented in the article on [[equality]], there are three notions of equality used in type theory: judgmental equality, propositional equality, and typal equality. All three notions of equality could be used as the internal definitional equality. In [[Martin-Löf type theory]] and [[cubical type theory]], [[judgmental equality]] is used for the internal definitional equality. In [[ZFC]] and [[ETCS]], [[propositional equality]] is used for the internal definitional equality, and in some [[objective type theories]], [[typal equality]] is used for the internal definitional equality. 

Returning back to the initial example given in the section above, one usually defines the symbol $2$ to be the term $s(s(0))$ in the type of [[natural numbers]]. The symbol $2$ is formally defined using the internal definitional equality as follows:

* Introduction and judgmental definition rules for $2$:

$$\frac{\Gamma \vdash \mathbb{N} \; \mathrm{type}}{\Gamma \vdash 2:\mathbb{N}} \qquad \frac{\Gamma \vdash \mathbb{N} \; \mathrm{type}}{\Gamma \vdash 2 = s(s(0)):\mathbb{N}}$$

* Introduction and propositional definition rules for $2$:

$$\frac{\Gamma \vdash \mathbb{N} \; \mathrm{type}}{\Gamma \vdash 2:\mathbb{N}} \qquad \frac{\Gamma \vdash \mathbb{N} \; \mathrm{type}}{\Gamma \vdash 2 =_{\mathbb{N}} s(s(0)) \; \mathrm{true}}$$

* Introduction and typal definition rules for $2$:

$$\frac{\Gamma \vdash \mathbb{N} \; \mathrm{type}}{\Gamma \vdash 2:\mathbb{N}} \qquad \frac{\Gamma \vdash \mathbb{N} \; \mathrm{type}}{\Gamma \vdash \delta_2:2 =_{\mathbb{N}} s(s(0))}$$

Similarly, the symbol $\mathrm{isProp}(A)$, which is usually defined as the type 
$$\prod_{x:A} \prod_{y:A} x =_A y$$ 
This is formally defined using the internal definitional equality as follows:

* Formation and judgmental definition rules for $\mathrm{isProp}(A)$:

$$\frac{\Gamma \vdash A \; \mathrm{type}}{\Gamma \vdash \mathrm{isProp}(A) \; \mathrm{type}} \qquad \frac{\Gamma \vdash A \; \mathrm{type}}{\Gamma \vdash \mathrm{isProp}(A) = \prod_{x:A} \prod_{y:A} x =_A y \; \mathrm{type}}$$

* Formation and propositional definition rules for $\mathrm{isProp}(A)$:

$$\frac{\Gamma \vdash A \; \mathrm{type}}{\Gamma \vdash \mathrm{isProp}(A) \; \mathrm{type}} \qquad \frac{\Gamma \vdash A \; \mathrm{type}}{\Gamma \vdash \mathrm{isProp}(A) = \prod_{x:A} \prod_{y:A} x =_A y\; \mathrm{true}}$$

* Formation and typal definition rules for $\mathrm{isProp}(A)$:

$$\frac{\Gamma \vdash A \; \mathrm{type}}{\Gamma \vdash \mathrm{isProp}(A) \; \mathrm{type}} \qquad \frac{\Gamma \vdash \mathrm{isProp}(A) \; \mathrm{type}}{\Gamma \vdash \delta_{\mathrm{isProp}(A)}:\mathrm{isProp}(A) \simeq \prod_{x:A} \prod_{y:A} x =_A y}$$

Assuming a [[dependent type theory with type variables]] and with [[identity type#IdentityTypesBetweenTypes|identity types between types]], the equivalence in the definition rule can be replaced with an [[identification]]:

$$\frac{\Gamma \vdash A \; \mathrm{type}}{\Gamma \vdash \mathrm{isProp}(A) \; \mathrm{type}} \qquad \frac{\Gamma \vdash \mathrm{isProp}(A) \; \mathrm{type}}{\Gamma \vdash \delta_{\mathrm{isProp}(A)}:\mathrm{isProp}(A) = \prod_{x:A} \prod_{y:A} x =_A y}$$

## History

The notion of definitional equality was introduced first in [[AUTOMATH]]. The following paper presents a suggestive explanation of this notion and how proof-checking was designed in this system (especially section 10):

[On the roles of types in mathematics](http://uf-ias-2012.wikispaces.com/file/view/deB1.pdf/401388596/deB1.pdf)

The notion of definitional equality was later introduced by [[Per Martin-Löf]], first in the context of normalization proofs for higher-order logic in the paper [Hauptsatz for Intuitionistic Simple Type Theory](http://www.sciencedirect.com/science/article/pii/S0049237X09703659) and generalized in Type Theory. He discusses this notion in the paper [About Models for Intuitionistic Type Theory and The notion of Definitional Equality](http://www.sciencedirect.com/science/article/pii/S0049237X08707274).

The extension from AUTOMATH is that one adds the notion of data type (natural number), of constructors (zero and successor) and primitive recursion as definitional equality. The motivation is that one can consider the schema of primitive recursion as a definition of a function.

This was also influenced by natural deduction, where constructors correspond to introduction rules and the work of Gödel on system T.

With this extension, one obtains a programming language with dependent types and where computations correspond to unfolding of definitions (that can be primitive recursive definitions). This programming language has the feature that all computations terminate. This has been also considered in functional programming, see e.g. the discussion in [this paper](http://uf-ias-2012.wikispaces.com/file/view/turner.pdf/401400700/turner.pdf).

A description of the evaluation algorithm using techniques from functional programming
can be found in [this work of Gregoire and Leroy](http://uf-ias-2012.wikispaces.com/file/view/strong-reduction.pdf/402005168/strong-reduction.pdf).  

## Note on terminology

Historically in the [[dependent type theory]] community, the term *definitional equality* was used for [[judgmental equality]]. This was because in the most common model of dependent type theory, [[Martin-Löf type theory]], judgmental equality was used for the internal definitional equality of the theory. However, we choose to make a distinction between definitional equality and judgmental equality, as not all type theories have judgmental equalities or internal definitional equalities: in particular, many [[objective type theories]] do not have judgmental equalities or an internal definitional equality, but nevertheless still have a metatheoretic definitional equality. 

Even if we restrict to internal definitional equality, there is still a distinction between definitional equality and judgmental equality. First, the internal definitional equality is [[propositional equality]] in the most common [[foundations of mathematics]], such as [[ZFC]] and [[ETCS]], instead of [[judgmental equality]]. In addition, one could work in [[logic]] over [[dependent type theory]] and replace [[judgmental equality]] entirely by [[propositional equality]] throughout the type theory, resulting in a type theory which behaves almost identically to the original type theory, only that the internal definitional equality is a proposition instead of a judgment (see the second presentation of [[Martin-Löf type theory]] on that article). Finally, in the advent of [[objective type theory]] and other dependent type theories which lack [[judgmental equality]] entirely, it is [[typal equality]] which is used in the internal [[definitional equality]]. 

## See also

* [[equality]], [[syntactic equality]], [[alpha-equivalence]]

* [[definition]]

## References

The first paper to mention intensional equality (and the fact that it should be decidable) may be: 

* [[Kurt Gödel]], _Über eine bisher noch nicht benützte Erweiterung des finiten Standpunktes_. Dialectica (1958), pp. 280–287, 

The distinction between definitional equality and "book" equality:

* [[Nicolaas de Bruijn]], _[[Automath]]_, 

The notion of definitional equality in the context of ([[dependent type theory|dependent]]) [[type theory]]:

* {#Thompson91} [[Simon Thompson]], §5.2.1 in: *[[Type Theory and Functional Programming]]*, Addison-Wesley (1991) &lbrack;ISBN:0-201-41667-0, [webpage](http://www.cs.kent.ac.uk/people/staff/sjt/TTFP), [pdf](http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/ttfp.pdf)&rbrack;

specifically in the [[Coq]] [[proof assistant]]: 

* [[Adam Chlipala]], §10.1 in: _Certified programming with dependent types_, MIT Press 2013 &lbrack;[ISBN:9780262026659 ](https://mitpress.mit.edu/books/certified-programming-dependent-types), [pdf](http://adam.chlipala.net/cpdt/cpdt.pdf),  [book webpage](http://adam.chlipala.net/cpdt/)&rbrack;


[[!redirects Definitional equality]]
[[!redirects definitional equalities]]
[[!redirects intensional equality]]
[[!redirects intensional equalities]]
[[!redirects extensional equality]]
[[!redirects extensional equalities]]