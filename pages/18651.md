+-- {: .rightHandSide}
+-- {: .toc .clickDown tabindex="0"}
###Context###
#### Constructivism, Realizability, Computability
+-- {: .hide}
[[!include constructivism - contents]]
=--
#### Category theory
+-- {: .hide}
[[!include category theory - contents]]
=--
=--
=--


# Duploid
* table of contents
{:toc}

## Idea

A **duploid** is a [[category]]-like structure where objects have a specific [[polarity in type theory|polarity]] and composition is not necessarily [[associative]].

Duploids are models of programming languages with explicitly polarized [[positive type|positive]] and [[negative type|negative]] types, accomodating both [[call-by-value]] and [[call-by-name]] programming paradigms.

A duploid can be constructed from an [[adjunction]] and the category of duploids is [[reflective subcategory|reflective]] in the category of adjunctions, equivalent to the subcategory of adjunctions satisfying an equalizing requirement.

## Definition

A **pre-duploid** $\mathcal{D}$ consists of

1. a set $|\mathcal{D}|$ of objects with a polarity map $\varpi : |\mathcal{D}| \to \{+,-\}$. If $\varpi(A) = +$, we say $A$ is positive and otherwise negative.
2. for every pair $A,B \in |\mathcal{D}|$ a set of morphisms $\mathcal{D}(A,B)$.
3. for every compatible pair of morphisms $f \in \mathcal{D}(A,B), g\in \mathcal{D}(B,C)$ a composite $g \odot f \in \mathcal{D}(A,C)$.
4. for every object $A$ an morphism $id_A \in \mathcal{D}(A,A)$ that is the identity with respect to composition.
5. For every $f \in \mathcal{D}(A,B), g \in \mathcal{D}(B,C), h \in \mathcal{D}(C,D)$, an associative law $f \odot (g \odot h) = (f \odot g) \odot h$ when $B$ is negative or $C$ is positive.

Note that when restricted to positive objects or negative objects, composition and identities form a category, written $\mathcal{P}$ and $\mathcal{N}$. When the polarity is known we write positive objects as $L,M,N$ and negative objects as $P,Q,R$. We call composition where the middle object is positive "positive composition" or "by-value composition" and notate it as $g \circ f$ and when the middle object is negative we call it "negative composition" or "by-name composition" and notate it as $g \bullet f$.
Then the associativity laws can be restated as:

1. $\bullet\bullet$: $f \bullet (g \bullet h)  = (f \bullet g) \bullet h$
2. $\circ\circ$: $f \circ (g \circ h)  = (f \circ g) \circ h$
3. $\circ\bullet$: $f \circ (g \bullet h)  = (f \bullet g) \circ h$

and we can see that the only obstacle to associativity is that $f \bullet (g \circ h)$ is not necessarily equal to $(f \bullet g) \circ h$.

A **duploid** is a pre-duploid $\mathcal{D}$ plus two **polarity shifts** 
$\Downarrow : |\mathcal{N}| \to |\mathcal{P}| and \Uparrow : |\mathcal{P}| \to |\mathcal{N}|$, and for each $P \in |\mathcal{P}|, N \in |\mathcal{N}|$, morphisms:

1. $\theta : P \to \Uparrow P$ (pronounced "thunk" or "delay")
2. $\epsilon : \Uparrow P \to P$ (pronounced "force")
3. $\eta : N \to \Downarrow N$ (pronounced "wrap")
4. $\rho : \Downarrow N \to N$ (pronounced "unwrap" or "run")

such that

1. $\forall f : A \to P, \epsilon \circ (\theta \bullet f) = f$
2. $\forall f : N \to A, (f \circ \rho) \bullet \eta = f$
3. $\theta \bullet \epsilon = id_{\Uparrow P}$
4. $\eta \circ \rho = id_{\Downarrow N}$

## Linear and Thunkable Morphisms

Just as thunkable morphisms can be defined in a [[thunk-force category]] and linear morphisms can be defined in a category with a [[runnable monad]], they can be defined in a duploid in  a similar way using the thunk and run morphisms.
However, thunkable and linear morphisms can also be defined in a _pre-duploid_, giving a simple characterization just in terms of associativity of composition.

A morphism $f$ is **thunkable** if for all compatible $g,h$,
$$h \odot (g \odot f) = (h \odot g) \odot f.$$
and a morphism $f$ is **linear** if for all compatible $g,h$,
$$f \odot (g \odot h) = (f \odot g) \odot h.$$

Observe that all $f : P \to B$ are trivially linear and $g : A \to N$ are trivially thunkable. Further thunkable and linear morphisms form (non-full) subcategories $\mathcal{D}_t, \mathcal{D}_l$.

To understand these concepts, consider the non-trivial situation where $f : A \to P$ is thunkable:
$$h \bullet (g \circ f) = (h \bullet g) \circ f.$$
on the left side, since we have a by-name composition, $h$ is "evaluated first", whereas on the right side we have a by-value composition, so $f$ is evaluated first.
Thus these two morphisms being equal implies in many semantics $f$ cannot perform any [[side-effect]]. For instance if $f$ prints to the screen and so does $h$, then each composite will print in a different order. Furthermore, if $f$ can manipulate its [[continuation]] explicitly, it has to treat it linearly otherwise $h$ may be evaluated twice or not at all.

In the dual, if $f : N \to B$ and $f$ is linear:
$$f \odot (g \odot h) = (f \odot g) \odot h$$
holds and similarly $f$ is evaluated first in the left morphism and $h$ is evaluated first in the right. Then as above it cannot perform any effects and has to treat its *input* linearly, as duplicating or dropping $h$ would make the equation fail to hold.

## Related Concepts

* [[polarity in type theory]]
* [[thunk-force category]]
* [[runnable monad]]

## References

Duploids were introduced in chapter II of

* {#Mthesis} Guillaume Munch-Maccagoni, Syntax and Models of a Non-Associative Composition of Programs and Proofs, PhD thesis University of Paris Diderot, 2013 [pdf link](http://guillaume.munch.name/files/SMAC-screen.pdf)