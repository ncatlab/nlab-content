+-- {: .rightHandSide}
+-- {: .toc .clickDown tabindex="0"}
###Context###
#### Constructivism, Realizability, Computability
+-- {: .hide}
[[!include constructivism - contents]]
=--
#### Category theory
+-- {: .hide}
[[!include category theory - contents]]
=--
=--
=--


# Duploid
* table of contents
{:toc}

## Idea

A **duploid** is a [[category]]-like structure where objects have a specific [[polarity in type theory|polarity]] and composition is not necessarily [[associative]].

Duploids are models of programming languages with explicitly polarized [[positive type|positive]] and [[negative type|negative]] types, accomodating both [[call-by-value]] and [[call-by-name]] programming paradigms.

A duploid can be constructed from an [[adjunction]] and the category of duploids is [[reflective subcategory|reflective]] in the category of adjunctions, equivalent to the subcategory of adjunctions satisfying an equalizing requirement.

## Definition

A **pre-duploid** $\mathcal{D}$ consists of

1. a set $|\mathcal{D}|$ of objects with a polarity map $\varpi : |\mathcal{D}| \to \{+,-\}$. If $\varpi(A) = +$, we say $A$ is positive and otherwise negative.
2. for every pair $A,B \in |\mathcal{D}|$ a set of morphisms $\mathcal{D}(A,B)$.
3. for every compatible pair of morphisms $f \in \mathcal{D}(A,B), g\in \mathcal{D}(B,C)$ a composite $g \odot f \in \mathcal{D}(A,C)$.
4. for every object $A$ an morphism $id_A \in \mathcal{D}(A,A)$ that is the identity with respect to composition.
5. For every $f \in \mathcal{D}(A,B), g \in \mathcal{D}(B,C), h \in \mathcal{D}(C,D)$, an associative law $f \odot (g \odot h) = (f \odot g) \odot h$ when $B$ is negative or $C$ is positive.

Note that when restricted to positive objects or negative objects, composition and identities form a category, written $\mathcal P$ and $\mathcal N$. When the polarity is known we write positive objects as $L,M,N$ and negative objects as $P,Q,R$. We also notate composition where the middle object is positive as $g \circ f$ and where the middle object is negative as $g \bullet f$.
Then the associativity laws can be restated as:

1. $\bullet\bullet$: $f \bullet (g \bullet h)  = (f \bullet g) \bullet h$
2. $\circ\circ$: $f \circ (g \circ h)  = (f \circ g) \circ h$
3. $\circ\bullet$: $f \circ (g \bullet h)  = (f \bullet g) \circ h$

and we can see that the only obstacle to associativity is that $f \bullet (g \circ h)$ is not necessarily equal to $(f \bullet g) \circ h$.

A **duploid** is a pre-duploid $\mathcal{D}$ plus two **polarity shifts** 
$\Downarrow : |\mathcal{N}| \to |\mathcal{P}| and \Uparrow : |\mathcal{P}| \to |\mathcal{N}|$, and for each $P \in |\mathcal{P}|, N \in |\mathcal{N}|$, morphisms:

1. $\theta : P \to \Uparrow P$ (pronounced "thunk" or "delay")
2. $\epsilon : \Uparrow P \to P$ (pronounced "force")
3. $\eta : N \to \Downarrow N$ (pronounced "wrap")
4. $\rho : \Downarrow N \to N$ (pronounced "unwrap" or "run")

such that

1. $\forall f : A \to P, \epsilon \circ (\theta \bullet f) = f$
2. $\forall f : N \to A, (f \circ \rho) \bullet \eta = f$
3. $\theta \bullet \epsilon = id_{\Uparrow P}$
4. $\eta \circ \rho = id_{\Downarrow N}$

## Related Concepts

* [[polarity in type theory]]
* [[thunk-force category]]
* [[runnable monad]]

## References

Duploids were introduced in chapter II of

* {#Mthesis} Guillaume Munch-Maccagoni, Syntax and Models of a Non-Associative Composition of Programs and Proofs, PhD thesis University of Paris Diderot, 2013 [pdf link](http://guillaume.munch.name/files/SMAC-screen.pdf)