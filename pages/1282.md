This entry illustrates by way of examples the concepts of categorical [[limit]] and [[colimit]], hence also in particular of [[product]] and [[coproduct]]. 

It starts with very elementary and simple examples and eventually passes to more sophisticated ones.

For examples of the other [[universal construction]]s see

* [[examples of adjoint functors]]

* [[examples of Kan extensions]]

#Examples of limits#

In the following examples, $D$ is a [[small category]], $C$ is any category and the limit is taken over a functor $F : D^{op} \to C$.

## simple diagrams ##


* the limit of the empty diagram $D = \emptyset$ in $C$ is, if it exists [[nLab:generalized the|the]] [[nLab:terminal object|terminal object]];

* if $D$ is a [[nLab:discrete category|discrete category]], i.e. a category with only identity morphisms, then a diagram $F : D \to C$ is just a collection $c_i$ of objects of $C$. Its limit is the [[nLab:product|product]] $\prod_i c_i$  of these.

* if $D = \{a \stackrel{\to}{\to} b\}$ then $lim F$ is the [[nLab:equalizer|equalizer]] of the two morphisms $F(b) \to F(a)$.

* if $D$ has an [[nLab:terminal object|terminal object]] $I$ (so that $I$ is an [[nLab:initial object|initial object]] in $D^{op}$), then the limit of any $F : D^{op} \to C$ is $F(I)$.

## filtered limits ##

* if $D$ is a [[nLab:poset|poset]], then the limit over $D^{op}$ is the supremum over the $F(d)$ with respect to $(F(d) \leq F(d')) \Leftrightarrow (F(d) \stackrel{F(\leq)}{\leftarrow} F(d'))$;

* the generalization of this is where the term "limit" for categorical limit (probably) originates from: for $D$ a [[nLab:filtered category|filtered category]], hence $D^{op}$ a cofiltered category, one may think of $(d \stackrel{f}{\to} d') \mapsto (F(d) \stackrel{F(f)}{\leftarrow} F(d')$ as witnessing that $F(d')$ is "larger than" $F(d)$ in some sense, and $lim F$ is then the "largest" of all these objecs, the limiting object. This interpretation is perhaps more evident for filtered [[nLab:colimit|colimits]], where the codomain category $C$ is thought of as being the [[nLab:opposite category|opposite]] $C = E^{op}$. See the motivation at [[nLab:ind-object|ind-object]].

## in terms of other operations ##

the limit of $F : D^{op} \to C$ is always a [[nLab:subobject|subobject]] of the [[nLab:product|product]] of the $F(d)$, namely the [[nLab:equalizer|equalizer]] of

$$
  \prod_{d \in Obj(D)}
  F(d)
  \stackrel{\prod_{f \in Mor(D)} (F(f) \circ p_{t(f)}) }{\to}  
  \prod_{f \in Mor(D)}
  F(s(f))
$$

and

$$
  \prod_{d \in Obj(D)}
  F(d)
  \stackrel{\prod_{f \in Mor(D)} (p_{s(f)}) }{\to}  
  \prod_{f \in Mor(D)}
  F(s(f))  
  \,.
$$

See the explicit formula for the limit in [[nLab:Set|Set]]
in terms of a subset of a product set.


In particular therefore, a category has all limits already if it has all products and equalizers.


## limits and colimits in Set ##

In the [[category]] [[Set]] of [[set]]s, [[limit]]s and [[colimit]]s reduce to the very familiar operations of 

* [[cartesian product]] of sets
* [[disjoint union]] of sets
* [[subset]]s defined by equations
* [[quotient set]]s of equivalence classes.

Conversely, [[limit]]s and [[colimit]]s in other categories may be regarded as generalizations of these concepts to things other than plain sets.


* the limit over any $F : D^{op} \to Set$ is $lim F = [D^{op}, Set](const_{pt}, F)$ -- this is equivalently

  * the set of [[nLab:natural transformation|natural transformations]] from the diagram constant on the [[nLab:point|point]] to $F$

  * the set of [[nLab:global element|global element]]s of $F$;

* therefore for every set $X$, there is a natural bijection
$Set(X, lim F) \simeq lim Set(X,F(-))$, where on the right the limit is taken of the functor $Set(X,F(-)) : D^{op} \to Set$.


* the limit over a [[nLab:Set|Set]]-valued functor $F : D^{op} \to Set$ is a subset of the product $\Pi_{d \in Obj(d)} F(d)$ of all objects: $lim F = \left\{ (s_d)_d \in \prod_d F(d) | for all (d \stackrel{f}{\to} d') : F(f)(s_{d'}) = s_d  \right\}$.


### limits in presheaf categorories ###

Here consider limits of functors $F : D^{op} to PSh(C)$
with values in the category of [[nLab:presheaf|presheaves]] on a [[nLab:small category|small category]] $C$.

**Proposition**

Limits of presheaves are computed objectwise:

$$
  lim F : c \mapsto lim F(-)(c)
$$ 

Here on the right the limit is over the functor 
$F(-)(c) : D^{op} \to Set$.


**Proposition**

The [[nLab:Yoneda embedding|Yoneda embedding]] 
$Y : C \to PSh(C)$ commutes with small limit:

Let $F : D^{op} \to C$, then

$$
  Y(lim F) \simeq lim Y\circ F
$$

(if either limit exists).












# Catgeorical coproduct: an explanation for programmers #

A web-based program that generates componentwise illustrations of simple [[limit]]s and [[colimit]]s in [[Set]] is developed at

* J. Paine, [Category Theory Demonstrations](http://www.j-paine.org/cgi-bin/webcats/webcats.php)


In this section, I'll explain coproducts by showing you a program that implements the categorical coproduct of sets. We programmers live our working lives surrounded by data structures and subroutines, entities that become as concrete to us &mdash; as "thing-like", as "manipulable" &mdash; as teacups and bricks. So if I can implement some categorical calculations as programs, I hope it will give them a sense of reality that the maths alone might lack. This way of explaining category theory isn't new, actually: it's the idea behind the following book, which implements categorical constructions in the programming language ML:

* [_Computational Category Theory_](http://www.cs.man.ac.uk/~david/categories/book/book.pdf), by [David Rydeheard](http://www.cs.man.ac.uk/~david/) and [Rod Burstall](http://www.dcs.ed.ac.uk/home/rb/).

## Preliminaries: functional programming in Python 3.0 ##

I'll implement my categorical coproduct in the programming language [Python 3.0](http://www.python.org/download/releases/3.0/). This is because: its syntax makes it easy to read; many programmers already know it; and it's free, so you can download it from the above link and try the examples yourself. 

But most importantly, Python supports [functional programming] (http://en.wikipedia.org/wiki/Functional_programming). That is, functions are [first-class citizens](http://en.wikipedia.org/wiki/First-class_object), meaning that one can assign them to variables and store them in datatypes, pass them into other functions as arguments and back from other functions as results, and construct them at runtime. 

In the next few paragraphs, I'll introduce Python 3.0 and then functional programming in Python. I'll do so by using it as a desk calculator, where I type commands &mdash; usually, expressions to be evaluated &mdash; and get back a result. If you want to try this, you can type them either into the Python command-line window, or into Python's IDLE graphical user-interface window.

As a start, this shows Python evaluating simple arithmetic expressions. What I type is after the three greater-than signs; Python's reply is on a line by itself:

    >>> 1
    1
    >>> 1+3
    4
    >>> 1+2*5
    11

I can store a result in a variable, and then use the variable as all or part of an expression. I'm showing you this because although the example below only stores numbers in variables, I shall later want to store functions. Please note that <code>eleven = 1+2*5</code> means "put the result of evaluating <code>1+2*5</code> into the variable <code>eleven</code>". Like many languages, Python uses the equals sign for assignment, which may be confusing if you're not a programmer:

    >>> eleven = 1+2*5
    >>> eleven
    11
    >>> eleven * 2
    22

I can call a function. The <code>from math import *</code> below merely gets me the built-in arithmetic functions, including <code>exp</code>, and isn't really very interesting:

    >>> from math import *
    >>> exp(1)
    2.7182818284590451

This is where it begins getting interesting. Below, I put the _function_ <code>exp</code> into the variable <code>myfunc</code>. I can then apply <code>myfunc</code> in the same way I did <code>exp</code>:

    >>> myfunc = exp
    >>> myfunc(1)
    2.7182818284590451

Instead of using <code>exp</code> as a function value, I can write a lambda expression \[ explain and link \]:

    >>> double = lambda x: 2*x
    >>> double(5)
    10

I now have all the prerequisites needed for some functional programming....

    >>> compose = lambda f, g: lambda x: g(f(x))

    >>> double_then_exp = compose( double, exp )
    >>> double_then_exp(1)
    7.3890560989306504
    >>> exp(2)
    7.3890560989306504 


## Categorical definition of coproduct ##

I'll start with the definition of coproduct, which I've lightly edited from Section 3, _Coproducts and Colimits_ in Chapter III. _Universals and Limits_, of:

* [_Categories for the Working Mathematician_], by Saunders Mac Lane.

> For any [[category]] $C$, a _coproduct diagram_ consists of [[object|objects]] $a$, $b$ and $c$ of $C$, and a pair of [[morphism|arrows]] $i:a\to c$ and $j:b\to c$. This pair has the familiar [[universal property]]: For any pair of arrows $f:a\to d$ and $g:b\to d$, there is a unique arrow $h:c\to d$, such that $f = i;h$ and $g = j;h$.

Before going on to an example, I must just explain that I am using semicolon to denote composition, with the meaning that $(i;h)(x)$ = $h(i(x))$. That is, we apply $i$ first, then $h$. As the page on [[composition]] explains, this is an alternative to the standard mathematical notation $h \circ i$: computer scientists often prefer the semicolon notation, because it reflects the order in which the functions get applied.

To create an example of a coproduct diagram, I'll start by defining the sets $a$, $b$ and $c$:

    a = { 'dimanche', 'lundi', 'mardi' };
    b = { 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag' };
    c = { 'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday' };

Python 3.0 has adopted mathematical notation for sets, enclosing them in curly brackets. Quotes enclose string constants, which I'm using to create arbitrary set elements.

Now I need the pair of arrows $i$ and $j$. I'll define these as functions:

    # Maps a to c.
    def i( x ): 
      if x == 'dimanche':
        return 'Sunday';
      elif x == 'lundi':
        return 'Monday';
      elif x == 'mardi':
        return 'Tuesday'; 

    # Maps b to c.
    def j( x ): 
      if x == 'Mittwoch':
        return 'Wednesday';
      elif x == 'Donnerstag':
        return 'Thursday';
      elif x == 'Freitag':
        return 'Friday';
      elif x == 'Samstag':
        return 'Saturday';

...\[Explain somewhere why I have made a and b not subsets of c. In examples where they are, perhaps readers don't see the purpose of the injections, so I want to make that explicit. Also, I shall later use this \[but maybe not appropriate topic for nLab? Though relevant to HDA&N\] to talk about "glueing data" (database merging, sensor fusion.)\]

One important point is that, to keep my program simple, I'm cheating a little bit. In category theory, essential parts of every arrow are its [[source]] and its [[target]]. Thus, the arrow $i$ that maps $a$ to $c$ is _different_ from an arrow that maps $a$ into &mdash; say &mdash; the set $\{'Sunday','Monday','Tuesday'\}$, or the set $\{'Sunday','Monday','Tuesday','Friday'\}$. This is so even if their mappings are the same. In computing terminology, we would say that essential parts of every arrow are its argument type and its result type. 

If I represent $i$ and $j$ by functions as above, I can't represent that in my code. But I shall do so by writing the source and target in a comment above every function. \[Perhaps I'll show a version later that does represent arrows. Use a dict with source, target, and body fields.\]

Now I'll show the definition of coproduct again: 

> For any category $C$, a _coproduct diagram_ consists of objects $a$, $b$ and $c$ of $C$, and a pair of arrows $i:a\to c$ and $j:b\to c$. This pair has the familiar universal property: For any pair of arrows $f:a\to d$ and $g:b\to d$, there is a unique arrow $h:c\to d$, such that $f = i;h$ and $g = j;h$. 

I have created the objects $a$, $b$ and $c$ and the arrows $i$ and $j$: \[insert diagram a<--i--c--j-->b. It would be really nice to (a) be able to click on the objects and arrows and see their content; (b) drag them around and manipulate them.\]. Now look at the sentence following "universal property". I'm going to change the wording slightly:

> You give me any pair of arrows $f:a\to d$ and $g:b\to d$, and I will give you a unique arrow $h:c\to d$, such that $f = i;h$ and $g = j;h$. 

But this sounds like a function talking! "You give me these arrows $f$ and $g$," it commands me, "and I will give you a new arrow $h$." \[ link in: CftWM 63, after (2), and the phrase "uniquely determined" \] So I am now going to implement a function that takes arrows $f$ and $g$ and returns our $h$. In fact, I want you to see the coproduct diagram \[a<--i--c--j-->b\] as such a function, so I am first going to implement another function that turns it into one. 

...\[To be continued\]

