This entry illustrates by way of examples the concepts of categorical [[limit]] and [[colimit]], hence also in particular of [[product]] and [[coproduct]]. 

It starts with very elementary and simple examples and eventually passes to more sophisticated ones.

For examples of the other [[universal construction]]s see

* [[examples of adjoint functors]]

* [[examples of Kan extensions]]

# Limits and colimits in Set #

In the [[category]] [[Set]] of [[set]]s, [[limit]]s and [[colimit]]s reduce to the very familiar operations of 

* [[cartesian product]] of sets
* [[disjoint union]] of sets
* [[subset]]s defined by equations
* [[quotient set]]s of equivalence classes.

Conversely, [[limit]]s and [[colimit]]s in other categories may be regarded as generalizations of these concepts to things other than plain sets.

A web-based program that generates componentwise illustrations of simple [[limit]]s and [[colimit]]s in [[Set]] is developed at

* J. Paine, [Category Theory Demonstrations](http://www.j-paine.org/cgi-bin/webcats/webcats.php)

## Catgeorical product of sets is cartesian product ##

## Catgeorical coproduct of sets is disjoint union ##

### Catgeorical coproduct: an explanation for programmers ###

In this section, I'll try explaining coproducts by showing you a program that calculates them. We programmers live our working lives surrounded by data structures and subroutines, entities that become as concrete to us &mdash; as "thing-like", as "manipulable" &mdash; as teacups and bricks. So if I can implement some categorical calculations as programs, I hope it will give them a sense of reality that the maths alone might lack. This way of explaining category theory isn't new, actually: it's the idea behind the book:

* [_Computational Category Theory_](http://www.cs.man.ac.uk/~david/categories/book/book.pdf), by [David Rydeheard](http://www.cs.man.ac.uk/~david/) and [Rod Burstall](http://www.dcs.ed.ac.uk/home/rb/). \[Do we have a convention for citing references?\] \[And what about linking to people, especially those in our field but perhaps not in the wiki? Must look this up, I think it's been discussed\]

I'll start with the definition of coproduct, which I've lightly edited from Section 3, _Coproducts and Colimits_ in Chapter III. _Universals and Limits_, of:

* [_Categories for the Working Mathematician_], by Saunders Mac Lane.

For any [[category]] $C$, a _coproduct diagram_ consists of [[object|objects]] $a$, $b$ and $c$ of $C$, and a pair of [[arrow|arrows]] $i:a\to c$ and $j:b\to c$. This pair has the familiar [[universal property]]: For any pair of arrows $f:a\to d$ and $g:b\to d$, there is a unique arrow $h:c\to d$, such that $f = i;h$ and $g = j;h$.

Before going on to an example, I must just explain that I am using semicolon to denote composition, with the meaning that $(i;h)(x)$ = $h(i(x))$. That is, we apply $i$ first, then $h$. As the page on [[composition]] explains, this is an alternative to the standard mathematical notation $h \circ i$: computer scientists often prefer the semicolon notation, because it reflects the order in which the functions get applied.

Now let me begin an example. I have programmed this in the programming language [Python 3.0](http://www.python.org/download/releases/3.0/). I chose Python 3.0 for several reasons. Firstly, it provides everything you need for _functional programming_ \[define FP?\]. That is, you can pass functions around as data, in the same way that you can common data types such as integers and strings. You can also write functions that operate on functions. These are essential when demonstrating category theory \[say why\]. Secondly, many programmers already know it; and for those who don't, it's easy to read. The syntax is less forbidding than Lisp, for instance. And thirdly, it's free! Just download it from the above site.

Another reason is that Python 3.0 makes it easy to manipulate sets. And my example sits in the category [[Set]] of [[set]]s. To create an example of a coproduct diagram, I'll start by defining the sets $a$, $b$ and $c$:

    a = { 'dimanche', 'lundi', 'mardi' };
    b = { 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag' };
    c = { 'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday' };

Python 3.0 has adopted mathematical notation for sets, enclosing them in curly brackets. Quotes enclose string constants, which I'm using to create arbitrary set elements.

Now I need the pair of arrows $i$ and $j$. I'll define these as functions:

    # Maps a to c.
    def i( x ): 
      if x == 'dimanche':
        return 'Sunday';
      elif x == 'lundi':
        return 'Monday';
      elif x == 'mardi':
        return 'Tuesday'; 

    # Maps b to c.
    def j( x ): 
      if x == 'Mittwoch':
        return 'Wednesday';
      elif x == 'Donnerstag':
        return 'Thursday';
      elif x == 'Freitag':
        return 'Friday';
      elif x == 'Samstag':
        return 'Saturday';

One important point is that, to keep my program simple, I'm cheating a little bit. In category theory, essential parts of every arrow are its [[source]] and its [[target]]. Thus, the arrow $i$ that maps $a$ to $c$ is _different_ from an arrow that maps $a$ into &mdash; say &mdash; the set { ${'Sunday','Monday','Tuesday'}$, or the set ${'Sunday','Monday','Tuesday','Friday'}$. This is so even if their mappings are the same. In computing terminology, we would say that essential parts of every arrow are its argument type and its result type. 

If I represent $i$ and $j$ by functions as above, I can't represent that in my code. But I shall do so by writing the source and target in a comment above every function. \[Perhaps I'll show a version later that does represent arrows. Use a dict with source, target, and body fields.\]

\[Now I want to plant a coproduct diagram. Can we do that and make it look nice? \]

# Etc #

## etc, pp. ##

## etc, ppp. ##