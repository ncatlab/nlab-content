This entry illustrates by way of examples the concepts of categorical [[limit]] and [[colimit]], hence also in particular of [[product]] and [[coproduct]]. 

It starts with very elementary and simple examples and eventually passes to more sophisticated ones.

For examples of the other [[universal construction]]s see

* [[examples of adjoint functors]]

* [[examples of Kan extensions]]

#Contents#

* [Examples of limits](#examplesoflimits)

  * [simple diagrams](#limitssimplediagrams)

  * [filtered limits](#filteredlimits)

  * [in term of other operations](#limitsintermsofotherops)

  * [limits and colimits in Set](#limcoliminset)
 
  * [limits in presheaf categories](#limitsinpresheafcat)

  * [limits in under categories](#limitsinundercat)


#Examples of limits {#examplesoflimits}

In the following examples, $D$ is a [[small category]], $C$ is any category and the limit is taken over a functor $F : D^{op} \to C$.

## simple diagrams {#limitssimplediagrams}


* the limit of the empty diagram $D = \emptyset$ in $C$ is, if it exists [[nLab:generalized the|the]] [[nLab:terminal object|terminal object]];

* if $D$ is a [[nLab:discrete category|discrete category]], i.e. a category with only identity morphisms, then a diagram $F : D \to C$ is just a collection $c_i$ of objects of $C$. Its limit is the [[nLab:product|product]] $\prod_i c_i$  of these.

* if $D = \{a \stackrel{\to}{\to} b\}$ then $lim F$ is the [[nLab:equalizer|equalizer]] of the two morphisms $F(b) \to F(a)$.

* if $D$ has an [[nLab:terminal object|terminal object]] $I$ (so that $I$ is an [[nLab:initial object|initial object]] in $D^{op}$), then the limit of any $F : D^{op} \to C$ is $F(I)$.

## filtered limits {#filteredlimits}

* if $D$ is a [[nLab:poset|poset]], then the limit over $D^{op}$ is the supremum over the $F(d)$ with respect to $(F(d) \leq F(d')) \Leftrightarrow (F(d) \stackrel{F(\leq)}{\leftarrow} F(d'))$;

* the generalization of this is where the term "limit" for categorical limit (probably) originates from: for $D$ a [[nLab:filtered category|filtered category]], hence $D^{op}$ a cofiltered category, one may think of $(d \stackrel{f}{\to} d') \mapsto (F(d) \stackrel{F(f)}{\leftarrow} F(d')$ as witnessing that $F(d')$ is "larger than" $F(d)$ in some sense, and $lim F$ is then the "largest" of all these objecs, the limiting object. This interpretation is perhaps more evident for filtered [[nLab:colimit|colimits]], where the codomain category $C$ is thought of as being the [[nLab:opposite category|opposite]] $C = E^{op}$. See the motivation at [[nLab:ind-object|ind-object]].

## in terms of other operations {#limitsintermsofotherops}

the limit of $F : D^{op} \to C$ is always a [[nLab:subobject|subobject]] of the [[nLab:product|product]] of the $F(d)$, namely the [[nLab:equalizer|equalizer]] of

$$
  \prod_{d \in Obj(D)}
  F(d)
  \stackrel{\prod_{f \in Mor(D)} (F(f) \circ p_{t(f)}) }{\to}  
  \prod_{f \in Mor(D)}
  F(s(f))
$$

and

$$
  \prod_{d \in Obj(D)}
  F(d)
  \stackrel{\prod_{f \in Mor(D)} (p_{s(f)}) }{\to}  
  \prod_{f \in Mor(D)}
  F(s(f))  
  \,.
$$

See the explicit formula for the limit in [[nLab:Set|Set]]
in terms of a subset of a product set.


In particular therefore, a category has all limits already if it has all products and equalizers.


## limits and colimits in Set {#limcoliminset}

In the [[category]] [[Set]] of [[set]]s, [[limit]]s and [[colimit]]s reduce to the very familiar operations of 

* [[cartesian product]] of sets
* [[disjoint union]] of sets
* [[subset]]s defined by equations
* [[quotient set]]s of equivalence classes.

Conversely, [[limit]]s and [[colimit]]s in other categories may be regarded as generalizations of these concepts to things other than plain sets.


* the limit over any $F : D^{op} \to Set$ is $lim F = [D^{op}, Set](const_{pt}, F)$ -- this is equivalently

  * the set of [[nLab:natural transformation|natural transformations]] from the diagram constant on the [[nLab:point|point]] to $F$

  * the set of [[nLab:global element|global element]]s of $F$;

* therefore for every set $X$, there is a natural bijection
$Set(X, lim F) \simeq lim Set(X,F(-))$, where on the right the limit is taken of the functor $Set(X,F(-)) : D^{op} \to Set$.


* the limit over a [[nLab:Set|Set]]-valued functor $F : D^{op} \to Set$ is a subset of the product $\Pi_{d \in Obj(d)} F(d)$ of all objects: $lim F = \left\{ (s_d)_d \in \prod_d F(d) | for all (d \stackrel{f}{\to} d') : F(f)(s_{d'}) = s_d  \right\}$.

* the colimit over a [[nLab:Set|Set]]-valued functor $F : D \to Set$ is a quotient set of the disjoint union $\coprod_{d \in Obj(D)} D(d)$: 
  $$ 
    colim F \simeq (\coprod_{d\in D} F(d))/_\sim \,, 
  $$
  where the equivalence relation $\sim$ is that which is _generated_ by 
  $$
    ((x \in F(d)) \sim (x' \in F(d'))) if (\exists (f : d \to d') with F(f)(x) = x')
  \,.
  $$
  If $D$ is a [[filtered category]] then the relation $\sim$ already is an equivalence relation.


### limits in presheaf categories {#limitsinpresheafcat}

Here consider limits of functors $F : D^{op} to PSh(C)$
with values in the category of [[nLab:presheaf|presheaves]] on a [[nLab:small category|small category]] $C$.

+-- {: .un_prop}
###### Proposition

Limits of presheaves are computed objectwise:
$$
  lim F : c \mapsto lim F(-)(c)
$$ 
Here on the right the limit is over the functor 
$F(-)(c) : D^{op} \to Set$.
=--

+-- {: .un_prop}
###### Proposition

The [[nLab:Yoneda embedding|Yoneda embedding]] 
$Y : C \to PSh(C)$ commutes with small limit:

Let $F : D^{op} \to C$, then we have
$$
  Y(lim F) \simeq lim (Y\circ F)
$$
if $lim F$ exists.
=--


## Limits in under-categories {#limitsinundercat}

Limits in [[under category|under categories]] are a special case of limits in [[comma category|comma categories]]. These are explained elsewhere. It may still be useful to spell out some details for the special case of under-categories. This is what the following does.


+-- {: .un_prop}
###### Proposition

Limits in an [[under category]] are computed as limits in the underlying category.

Precisely: let $C$ be a [[category]], $t \in C$ an [[object]], and $t/C$ the corresponding [[under category]], and $p : t/C \to C$ the obvious projection.

Let $F : D \to t/C$ be any [[functor]]. Then, if it exists, the [[limit]] over $p \circ F$ in $C$ is the image under $p$ of the limit over $F$:

$$
  p(\lim F)  \simeq \lim (p F)
$$

and $\lim F$ is uniquely characterized by $\lim (p F)$.


=--
 
+-- {: .proof}
###### Proof

Over a morphism $\gamma : d \to d'$ in $D$ the limiting cone over $p F$  (which exists by assumption) looks like

$$
  \array{
    && \lim p F
    \\
    & \swarrow && \searrow
    \\
    p F(d) &&\stackrel{p F(\gamma)}{\to}&& p F(d') 
  }
$$


By the universal property of the limit this has a unique
lift to a cone in the [[under category]] $t/C$ over $F$:

$$
  \array{
    && t 
    \\
    & \swarrow &\downarrow & \searrow
    \\
    && \lim p F
    \\
    \downarrow & \swarrow && \searrow & \downarrow
    \\
    p F(d) &&\stackrel{p F(\gamma)}{\to}&& p F(d') 
  }
$$


It therefore remains to show that this is indeed a limiting cone over $F$. Again, this is immediate from the universal property of the limit in $C$. For let $t \to Q$ be another cone over $F$ in $t/C$, then $Q$ is another cone over $p F$ in $C$ and we get in $C$ a universal morphism $Q \to \lim p F$

$$
  \array{
    && t
    \\
    & \swarrow & \downarrow & \searrow
    \\
    && Q
    \\
    \downarrow & \swarrow &\downarrow & \searrow & \downarrow
    \\
    && \lim p F
    \\
    \downarrow & \swarrow && \searrow & \downarrow
    \\
    p F(d) &&\stackrel{p F(\gamma)}{\to}&& p F(d') 
  }
$$


A glance at the diagram above shows that
the composite $t \to Q \to \lim p F$ constitutes a morphism
of cones in $C$ into the limiting cone over $p F$. Hence it must equal our morphism $t \to \lim p F$, by the universal property of $\lim p F$, and hence the above diagram does commute as indicated.

This shows that the morphism $Q \to \lim p F$
which was the unique one giving a cone morphism on $C$ does lift to a
cone morphism in $t/C$, which is then necessarily unique, too.  This demonstrates the required universal property of $t \to \lim p F$ and 
thus identifies it with $\lim F$.


=--


+--{.query}

>the following discussion originated from an earler version of this entry

[[Todd Trimble]]: So far, this is a really good article. However, I would not say in this last line "if either limit exists", because small limits on the right certainly exist always since $Set$ is complete; instead, "if $lim F$ exists". 

[[Urs Schreiber|Urs]]: thanks, Todd, I have changed the above now accordingly. Please don't hesitate to correct and/or improve things you see as needed.

By the way, I am not completely happy with this entry as yet. It was originally motivated from the desire to 
_explain_ in small steps the computation of limits and colimits to those readers unfamiliar with it. Currently this here mostly just lists results, where maybe we would eventually want to include also pedagocial proofs. 

The material below "explanation for programmers" goes more in that pedagogical direction, though I'd think eventually it would be good to also have the kind of pedestrian explanation given there but without (at first) its realization in Python! :-)

=--









# Catgeorical coproduct: an explanation for programmers #

+--{.query}

[[Urs Schreiber]]: sorry to say this, but I am not so happy with the following material here at this particular entry. This entry here is supposed to explain limits and colimits. Originally I thought that the computer program described below should be _used_ here to _help explain_ limits and colimits. For instance by using its graphical output for illustration purposes. But instead the material below explains how to _write that program_ . That may be of interest, too, but here at this entry it seems a bit of a distraction. Could we move the following material to its seperate entry? 

=--


A web-based program that generates componentwise illustrations of simple [[limit]]s and [[colimit]]s in [[Set]] is developed at

* J. Paine, [Category Theory Demonstrations](http://www.j-paine.org/cgi-bin/webcats/webcats.php)


In this section, I'll explain coproducts by showing you a program that implements the categorical coproduct of sets. We programmers live our working lives surrounded by data structures and subroutines, entities that become as concrete to us &mdash; as "thing-like", as "manipulable" &mdash; as teacups and bricks. So if I can implement some categorical calculations as programs, I hope it will give them a sense of reality that the maths alone might lack. This way of explaining category theory isn't new, actually: it's the idea behind the following book, which implements categorical constructions in the programming language ML:

* [_Computational Category Theory_](http://www.cs.man.ac.uk/~david/categories/book/book.pdf), by [David Rydeheard](http://www.cs.man.ac.uk/~david/) and [Rod Burstall](http://www.dcs.ed.ac.uk/home/rb/).

## Preliminaries: functional programming in Python 3.0 ##

I'll implement my categorical coproduct in the programming language [Python 3.0](http://www.python.org/download/releases/3.0/). This is because: its syntax makes it easy to read; many programmers already know it; and it's free, so you can download it from the above link and try the examples yourself. 

But most importantly, Python supports [functional programming] (http://en.wikipedia.org/wiki/Functional_programming). That is, functions are [first-class citizens](http://en.wikipedia.org/wiki/First-class_object), meaning that one can assign them to variables and store them in datatypes, pass them into other functions as arguments and back from other functions as results, and construct them at runtime. 

In the next few paragraphs, I'll introduce Python 3.0 and then functional programming in Python. I'll do so by using it as a desk calculator, where I type commands &mdash; usually, expressions to be evaluated &mdash; and get back a result. If you want to try this, you can type them either into the Python command-line window, or into Python's IDLE graphical user-interface window.

As a start, this shows Python evaluating simple arithmetic expressions. What I type is after the three greater-than signs; Python's reply is on a line by itself:

    >>> 1
    1
    >>> 1+3
    4
    >>> 1+2*5
    11

I can store a result in a variable, and then use the variable as all or part of an expression. I'm showing you this because although the example below only stores numbers in variables, I shall later want to store functions. Please note that <code>eleven = 1+2*5</code> means "put the result of evaluating <code>1+2*5</code> into the variable <code>eleven</code>". Like many languages, Python uses the equals sign for assignment, which may be confusing if you're not a programmer:

    >>> eleven = 1+2*5
    >>> eleven
    11
    >>> eleven * 2
    22

I can call a function. The <code>from math import *</code> below merely gets me the built-in arithmetic functions, including <code>exp</code>, and isn't really very interesting:

    >>> from math import *
    >>> exp(1)
    2.7182818284590451

This is where it begins getting interesting. Below, I put the _function_ <code>exp</code> into the variable <code>myfunc</code>. I can then apply <code>myfunc</code> in the same way I did <code>exp</code>:

    >>> myfunc = exp
    >>> myfunc(1)
    2.7182818284590451

Instead of using <code>exp</code> as a function value, I can write a "lambda expression":

    >>> identity = lambda x: x
    >>> identity(5)
    5
    >>> double = lambda x: 2*x
    >>> double(5)
    10

A lambda expression denotes a function without naming it or hiving it off into a separate definition. Then, in the same way that 1 denotes an integer and can be used as a constant in a language of arithmetic expressions, a lambda expression can be used in a language of expressions over functions. You can see this in the interaction below, where I have applied a lambda expression to 5. The syntax is the same as for <code>double(5)</code>, except that in place of <code>double</code>, we have the lambda expression:

    >>> (lambda x: 2*x)(5)
    10

By the way, lambda expressions arose as part of the lambda calculus. \[ Possibly put some of this on a new lambda calculus page \] This is a mathematical model of computation,  invented by the logician [Alonzo Church](http://en.wikipedia.org/wiki/Alonzo_Church) as a foundation for logic. (One topic he wanted to investigate was G&ouml;del's incompleteness theorem, hoping it might not apply to logic founded on the lambda calculus.) It consists of a language of expressions over values which include functions, and a set of transformation rules for evaluating these expressions. His notation for functions used Greek lambda to signal a function's argument: in it, the identity function is written $\lambda x.x$. Python's <code>lambda x: x</code>, and lambda expressions in other programming languages, are keyboard approximations to this notation. I should note that the phrase "lambda expression" seems to be ambiguous: some people use it only for functions written using lambda notation, while others use it to mean any expression in the lambda calculus. I suspect, though I haven't yet looked at Church's original paper, that he used it in the first sense. You'll find some online references about the lambda calculus at the n-Category Caf&eacute; thread [_Classical vs Quantum Computation (Week 1)_](http://golem.ph.utexas.edu/category/2006/10/classical_vs_quantum_computati.html), and a history of it at:

* [_History of Lambda-calculus and
Combinatory Logic_](http://www-maths.swan.ac.uk/staff/jrh/papers/JRHHislamWeb.pdf), by Felice Cardone and J. Roger Hindley.

... I now have all the prerequisites needed for some functional programming....

    >>> compose = lambda f, g: lambda x: g(f(x))

    >>> double_then_exp = compose( double, exp )
    >>> double_then_exp(1)
    7.3890560989306504
    >>> exp(2)
    7.3890560989306504 


## Categorical definition of coproduct ##

I'll start with the definition of coproduct, which I've lightly edited from Section 3, _Coproducts and Colimits_ in Chapter III. _Universals and Limits_, of:

* [_Categories for the Working Mathematician_], by Saunders Mac Lane.

> For any [[category]] $C$, a _coproduct diagram_ consists of [[object|objects]] $a$, $b$ and $c$ of $C$, and a pair of [[morphism|arrows]] $i:a\to c$ and $j:b\to c$. This pair has the familiar [[universal property]]: For any pair of arrows $f:a\to d$ and $g:b\to d$, there is a unique arrow $h:c\to d$, such that $f = i;h$ and $g = j;h$.

Before going on to an example, I must just explain that I am using semicolon to denote composition, with the meaning that $(i;h)(x)$ = $h(i(x))$. That is, we apply $i$ first, then $h$. As the page on [[composition]] explains, this is an alternative to the standard mathematical notation $h \circ i$: computer scientists often prefer the semicolon notation, because it reflects the order in which the functions get applied.

To create an example of a coproduct diagram, I'll start by defining the sets $a$, $b$ and $c$:

    a = { 'dimanche', 'lundi', 'mardi' };
    b = { 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag' };
    c = { 'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday' };

Python 3.0 has adopted mathematical notation for sets, enclosing them in curly brackets. Quotes enclose string constants, which I'm using to create arbitrary set elements.

Now I need the pair of arrows $i$ and $j$. I'll define these as functions:

    # Maps a to c.
    def i( x ): 
      if x == 'dimanche':
        return 'Sunday';
      elif x == 'lundi':
        return 'Monday';
      elif x == 'mardi':
        return 'Tuesday'; 

    # Maps b to c.
    def j( x ): 
      if x == 'Mittwoch':
        return 'Wednesday';
      elif x == 'Donnerstag':
        return 'Thursday';
      elif x == 'Freitag':
        return 'Friday';
      elif x == 'Samstag':
        return 'Saturday';

...\[Explain somewhere why I have made a and b not subsets of c. In examples where they are, perhaps readers don't see the purpose of the injections, so I want to make that explicit. Also, I shall later use this \[but maybe not appropriate topic for nLab? Though relevant to HDA&N\] to talk about "glueing data" (database merging, sensor fusion.)\]

One important point is that, to keep my program simple, I'm cheating a little bit. In category theory, essential parts of every arrow are its [[source]] and its [[target]]. Thus, the arrow $i$ that maps $a$ to $c$ is _different_ from an arrow that maps $a$ into &mdash; say &mdash; the set $\{'Sunday','Monday','Tuesday'\}$, or the set $\{'Sunday','Monday','Tuesday','Friday'\}$. This is so even if their mappings are the same. In computing terminology, we would say that essential parts of every arrow are its argument type and its result type. 

If I represent $i$ and $j$ by functions as above, I can't represent that in my code. But I shall do so by writing the source and target in a comment above every function. \[Perhaps I'll show a version later that does represent arrows. Use a dict with source, target, and body fields.\]

Now I'll show the definition of coproduct again: 

> For any category $C$, a _coproduct diagram_ consists of objects $a$, $b$ and $c$ of $C$, and a pair of arrows $i:a\to c$ and $j:b\to c$. This pair has the familiar universal property: For any pair of arrows $f:a\to d$ and $g:b\to d$, there is a unique arrow $h:c\to d$, such that $f = i;h$ and $g = j;h$. 

I have created the objects $a$, $b$ and $c$ and the arrows $i$ and $j$: \[insert diagram a<--i--c--j-->b. It would be really nice to (a) be able to click on the objects and arrows and see their content; (b) drag them around and manipulate them.\]. Now look at the sentence following "universal property". I'm going to change the wording slightly:

> You give me any pair of arrows $f:a\to d$ and $g:b\to d$, and I will give you a unique arrow $h:c\to d$, such that $f = i;h$ and $g = j;h$. 

But this sounds like a function talking! "You give me these arrows $f$ and $g$," it commands me, "and I will give you a new arrow $h$." \[ link in: CftWM 63, after (2), and the phrase "uniquely determined" \] So I am now going to implement a function that takes arrows $f$ and $g$ and returns our $h$. In fact, I want you to see the coproduct diagram \[a<--i--c--j-->b\] as such a function, so I am first going to implement another function that turns it into one. 

...\[To be continued\]


#References#

* [[The Catsters]], [General Limits and Colimits](http://www.youtube.com/watch?v=g47V6qxKQNU)
