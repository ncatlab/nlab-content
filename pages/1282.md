This entry illustrates by way of examples the concepts of categorical [[limit]] and [[colimit]], hence also in particular of [[product]] and [[coproduct]]. 

It starts with very elementary and simple examples and eventually passes to more sophisticated ones.

For examples of the other [[universal construction]]s see

* [[examples of adjoint functors]]

* [[examples of Kan extensions]]

#Examples of limits#

In the following examples, $D$ is a [[small category]], $C$ is any category and the limit is taken over a functor $F : D^{op} \to C$.

## simple diagrams ##


* the limit of the empty diagram $D = \emptyset$ in $C$ is, if it exists [[nLab:generalized the|the]] [[nLab:terminal object|terminal object]];

* if $D$ is a [[nLab:discrete category|discrete category]], i.e. a category with only identity morphisms, then a diagram $F : D \to C$ is just a collection $c_i$ of objects of $C$. Its limit is the [[nLab:product|product]] $\prod_i c_i$  of these.

* if $D = \{a \stackrel{\to}{\to} b\}$ then $lim F$ is the [[nLab:equalizer|equalizer]] of the two morphisms $F(b) \to F(a)$.

* if $D$ has an [[nLab:terminal object|terminal object]] $I$ (so that $I$ is an [[nLab:initial object|initial object]] in $D^{op}$), then the limit of any $F : D^{op} \to C$ is $F(I)$.

## filtered limits ##

* if $D$ is a [[nLab:poset|poset]], then the limit over $D^{op}$ is the supremum over the $F(d)$ with respect to $(F(d) \leq F(d')) \Leftrightarrow (F(d) \stackrel{F(\leq)}{\leftarrow} F(d'))$;

* the generalization of this is where the term "limit" for categorical limit (probably) originates from: for $D$ a [[nLab:filtered category|filtered category]], hence $D^{op}$ a cofiltered category, one may think of $(d \stackrel{f}{\to} d') \mapsto (F(d) \stackrel{F(f)}{\leftarrow} F(d')$ as witnessing that $F(d')$ is "larger than" $F(d)$ in some sense, and $lim F$ is then the "largest" of all these objecs, the limiting object. This interpretation is perhaps more evident for filtered [[nLab:colimit|colimits]], where the codomain category $C$ is thought of as being the [[nLab:opposite category|opposite]] $C = E^{op}$. See the motivation at [[nLab:ind-object|ind-object]].

## in terms of other operations ##

the limit of $F : D^{op} \to C$ is always a [[nLab:subobject|subobject]] of the [[nLab:product|product]] of the $F(d)$, namely the [[nLab:equalizer|equalizer]] of

$$
  \prod_{d \in Obj(D)}
  F(d)
  \stackrel{\prod_{f \in Mor(D)} (F(f) \circ p_{t(f)}) }{\to}  
  \prod_{f \in Mor(D)}
  F(s(f))
$$

and

$$
  \prod_{d \in Obj(D)}
  F(d)
  \stackrel{\prod_{f \in Mor(D)} (p_{s(f)}) }{\to}  
  \prod_{f \in Mor(D)}
  F(s(f))  
  \,.
$$

See the explicit formula for the limit in [[nLab:Set|Set]]
in terms of a subset of a product set.


In particular therefore, a category has all limits already if it has all products and equalizers.


## limits and colimits in Set ##

In the [[category]] [[Set]] of [[set]]s, [[limit]]s and [[colimit]]s reduce to the very familiar operations of 

* [[cartesian product]] of sets
* [[disjoint union]] of sets
* [[subset]]s defined by equations
* [[quotient set]]s of equivalence classes.

Conversely, [[limit]]s and [[colimit]]s in other categories may be regarded as generalizations of these concepts to things other than plain sets.


* the limit over any $F : D^{op} \to Set$ is $lim F = [D^{op}, Set](const_{pt}, F)$ -- this is equivalently

  * the set of [[nLab:natural transformation|natural transformations]] from the diagram constant on the [[nLab:point|point]] to $F$

  * the set of [[nLab:global element|global element]]s of $F$;

* therefore for every set $X$, there is a natural bijection
$Set(X, lim F) \simeq lim Set(X,F(-))$, where on the right the limit is taken of the functor $Set(X,F(-)) : D^{op} \to Set$.


* the limit over a [[nLab:Set|Set]]-valued functor $F : D^{op} \to Set$ is a subset of the product $\Pi_{d \in Obj(d)} F(d)$ of all objects: $lim F = \left\{ (s_d)_d \in \prod_d F(d) | for all (d \stackrel{f}{\to} d') : F(f)(s_{d'}) = s_d  \right\}$.


### limits in presheaf categorories ###

Here consider limits of functors $F : D^{op} to PSh(C)$
with values in the category of [[nLab:presheaf|presheaves]] on a [[nLab:small category|small category]] $C$.

**Proposition**

Limits of presheaves are computed objectwise:

$$
  lim F : c \mapsto lim F(-)(c)
$$ 

Here on the right the limit is over the functor 
$F(-)(c) : D^{op} \to Set$.


**Proposition**

The [[nLab:Yoneda embedding|Yoneda embedding]] 
$Y : C \to PSh(C)$ commutes with small limit:

Let $F : D^{op} \to C$, then

$$
  Y(lim F) \simeq lim Y\circ F
$$

(if either limit exists).












# Catgeorical coproduct: an explanation for programmers #

A web-based program that generates componentwise illustrations of simple [[limit]]s and [[colimit]]s in [[Set]] is developed at

* J. Paine, [Category Theory Demonstrations](http://www.j-paine.org/cgi-bin/webcats/webcats.php)


In this section, I'll try explaining coproducts by showing you a program that calculates them. We programmers live our working lives surrounded by data structures and subroutines, entities that become as concrete to us &mdash; as "thing-like", as "manipulable" &mdash; as teacups and bricks. So if I can implement some categorical calculations as programs, I hope it will give them a sense of reality that the maths alone might lack. This way of explaining category theory isn't new, actually: it's the idea behind the book:

* [_Computational Category Theory_](http://www.cs.man.ac.uk/~david/categories/book/book.pdf), by [David Rydeheard](http://www.cs.man.ac.uk/~david/) and [Rod Burstall](http://www.dcs.ed.ac.uk/home/rb/). \[Do we have a convention for citing references?\] \[And what about linking to people, especially those in our field but perhaps not in the wiki? Must look this up, I think it's been discussed\]

I'll start with the definition of coproduct, which I've lightly edited from Section 3, _Coproducts and Colimits_ in Chapter III. _Universals and Limits_, of:

* [_Categories for the Working Mathematician_], by Saunders Mac Lane.

> For any [[category]] $C$, a _coproduct diagram_ consists of [[object|objects]] $a$, $b$ and $c$ of $C$, and a pair of [[arrow|arrows]] $i:a\to c$ and $j:b\to c$. This pair has the familiar [[universal property]]: For any pair of arrows $f:a\to d$ and $g:b\to d$, there is a unique arrow $h:c\to d$, such that $f = i;h$ and $g = j;h$.

Before going on to an example, I must just explain that I am using semicolon to denote composition, with the meaning that $(i;h)(x)$ = $h(i(x))$. That is, we apply $i$ first, then $h$. As the page on [[composition]] explains, this is an alternative to the standard mathematical notation $h \circ i$: computer scientists often prefer the semicolon notation, because it reflects the order in which the functions get applied.

Now let me begin an example. I have programmed this in the programming language [Python 3.0](http://www.python.org/download/releases/3.0/). I chose Python 3.0 for several reasons. Firstly, it provides everything you need for _functional programming_ \[define FP?\]. That is, you can pass functions around as data, in the same way that you can common data types such as integers and strings. You can also write functions that operate on functions. These are essential when demonstrating category theory \[say why\]. Secondly, many programmers already know it; and for those who don't, it's easy to read. The syntax is less forbidding than Lisp, for instance. And thirdly, it's free! Just download it from the above site. \[Call it "Python 3.0" or "Python 3", or just "Python" after the first mention? "3.0" all the time sounds cumbersome.\]

Another reason is that Python 3.0 makes it easy to manipulate sets. And my example sits in the category [[Set]] of [[set]]s. \[Links to Set and set?\] To create an example of a coproduct diagram, I'll start by defining the sets $a$, $b$ and $c$:

    a = { 'dimanche', 'lundi', 'mardi' };
    b = { 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag' };
    c = { 'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday' };

Python 3.0 has adopted mathematical notation for sets, enclosing them in curly brackets. Quotes enclose string constants, which I'm using to create arbitrary set elements.

Now I need the pair of arrows $i$ and $j$. I'll define these as functions:

    # Maps a to c.
    def i( x ): 
      if x == 'dimanche':
        return 'Sunday';
      elif x == 'lundi':
        return 'Monday';
      elif x == 'mardi':
        return 'Tuesday'; 

    # Maps b to c.
    def j( x ): 
      if x == 'Mittwoch':
        return 'Wednesday';
      elif x == 'Donnerstag':
        return 'Thursday';
      elif x == 'Freitag':
        return 'Friday';
      elif x == 'Samstag':
        return 'Saturday';

...\[Explain somewhere why I have made a and b not subsets of c. In examples where they are, perhaps readers don't see the purpose of the injections, so I want to make that explicit. Also, I shall later use this \[but maybe not appropriate topic for nLab? Though relevant to HDA&N\] to talk about "glueing data" (database merging, sensor fusion.)\]

One important point is that, to keep my program simple, I'm cheating a little bit. In category theory, essential parts of every arrow are its [[source]] and its [[target]]. Thus, the arrow $i$ that maps $a$ to $c$ is _different_ from an arrow that maps $a$ into &mdash; say &mdash; the set $\{'Sunday','Monday','Tuesday'\}$, or the set $\{'Sunday','Monday','Tuesday','Friday'\}$. This is so even if their mappings are the same. In computing terminology, we would say that essential parts of every arrow are its argument type and its result type. 

If I represent $i$ and $j$ by functions as above, I can't represent that in my code. But I shall do so by writing the source and target in a comment above every function. \[Perhaps I'll show a version later that does represent arrows. Use a dict with source, target, and body fields.\]

Now I'll show the definition of coproduct again: 

> For any category $C$, a _coproduct diagram_ consists of objects $a$, $b$ and $c$ of $C$, and a pair of arrows $i:a\to c$ and $j:b\to c$. This pair has the familiar universal property: For any pair of arrows $f:a\to d$ and $g:b\to d$, there is a unique arrow $h:c\to d$, such that $f = i;h$ and $g = j;h$. 

I have created the objects $a$, $b$ and $c$ and the arrows $i$ and $j$: \[insert diagram a<--i--c--j-->b. It would be really nice to (a) be able to click on the objects and arrows and see their content; (b) drag them around and manipulate them.\]. Now look at the sentence following "universal property". I'm going to change the wording slightly:

> You give me any pair of arrows $f:a\to d$ and $g:b\to d$, and I will give you a unique arrow $h:c\to d$, such that $f = i;h$ and $g = j;h$. 

But this sounds like a function talking! "You give me these arrows $f$ and $g$," it commands me, "and I will give you a new arrow $h$." \[ link in: CftWM 63, after (2), and the phrase "uniquely determined" \] So I am now going to implement a function that takes arrows $f$ and $g$ and returns our $h$. In fact, I want you to see the coproduct diagram \[a<--i--c--j-->b\] as such a function, so I am first going to implement another function that turns it into one. 

...\[Here, link to preliminaries needed to explain Python as a functional language. Maybe do that in the para that first mentioned Python, and refer back to it here.\]

...\[To be continued\]

