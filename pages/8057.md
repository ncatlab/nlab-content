
# Fixed-point combinators
* table of contents
{: toc}

## Idea 

In [[combinatory logic]], in the [[λ-calculus]], or more generally in [[type theory]], a fixed-point [[combinator]] is a term $Y$ which, when applied to a term $n$, yields a term $Y n$ that is a fixed-point of $n$:
$$ n (Y n) = Y n .$$
This equality is usually a directed [[beta-reduction]] as follows:
$$ Y n \to_\beta n (Y n) .$$


## Implementing general recursion

When "programming" in any of these systems, a fixed-point combinator serves as a mechanism for implementing general [[recursion]].  When writing a recursive function in a standard programming language, such as the [[factorial]]

    def fact(n:nat) : nat = {
      if (n == 0) {
        return 1
      } else {
        return n * fact(n-1)
      }
    }

one generally calls the function being defined inside of its own body.  This is not possible for a combinator or a lambda-term to do directly, but it can be implemented using a fixed-point combinator.  One first defines a "generator" which takes "the function to call recursively" as an additional argument:

    def genfact(f : nat -> nat)(n:nat) : nat = {
     if (n == 0) {
       return 1
     } else {
       return n * f(n-1)
     }
   }

and then "closes the loop" by applying the fixed-point combinator.  That is, we [[currying|curry]] `genfact` to view it as an endofunction of `nat -> nat` (a "functional") and then construct its fixed point, 

$$ fact = Y(genfact). $$

The directed $\beta$-reduction version of the fixed-point property of $Y$ then implements the process of calling a function recursively:

$$
\begin{aligned}
  fact(3) &= Y(genfact)(3)\\
  &\to_\beta genfact(Y(genfact))(3)\\
  &\to_\beta 3 * Y(genfact)(2)\\
  &\to_\beta 3 * genfact(Y(genfact))(2)\\
  &\to_\beta 3 * 2 * Y(genfact)(1)\\
  &\to_\beta 3 * 2 * genfact(Y(genfact))(1)\\
  &\to_\beta 3 * 2 * 1 * Y(genfact)(0)\\
  &\to_\beta 3 * 2 * 1 * genfact(Y(genfact))(0)\\
  &\to_\beta 3 * 2 * 1 * 1\\
  &= 6
\end{aligned}
$$

In particular, observe that because general recursion allows the definition of nonterminating functions, so does a fixed-point combinator.  An obvious example is the fixed point of the identity function $I$, which reduces as follows:

$$ Y I \to_\beta I(Y I) \to_\beta Y I \to_\beta I(Y I) \to_\beta Y I \to_\beta \cdots  $$


## Existence

There are many ways of constructing or otherwise obtaining a fixed-point combinator, varying with the formal system in which one works.

### Unityped $\lambda$-calculus

In the [[unityped λ-calculus]], a traditional construction is

$$ Y = \lambda n. (\lambda s. n (s s)) (\lambda s. n (s s)) $$ 

For a given term $n$, put $t = \lambda s. n (s s)$. We then have $Y n = t t$, and we also have 

$$ \array {
Y n & = & (\lambda s. n (s s)) (\lambda s. n (s s)) \\
 & = & (\lambda s. n (s s)) (t) \\ 
 & = & n (t t) \\ 
 & = & n (Y n)
}$$ 

so that $Y n$ is a fixed point of $n$. Compare Lawvere's proof of [[Cantor's theorem]]. 

### Combinatory logic

In [[combinatory logic]] (based on the combinators $S$, $K$, and $I$), one construction is  

$$ Y = S (K (S I I)) (S (S (K S) K) (K (S I I))) $$ 

following the standard formulas $S x y z = (x z)(y z)$, $K x y = x$ and $I x = x$, and where bracketings left unspecified are by convention to the left. (To be expanded...) 

### Typed $\lambda$-calculus

In many forms of (multi-) *typed* $\lambda$-calculus (and more general type theory), a fixed-point combinator cannot be constructed, because there is no type whose terms can be applied to themselves.  This is usually intentional, because it avoids the nontermination inherent in the existence of a fixed-point combinator.

However, it is possible to add a fixed-point combinator to typed $\lambda$-calculus by fiat, obtaining a typed system which includes general recursion and hence nontermination.  This is appropriate for some forms of [[domain semantics]], and for modeling some real-world programming languages ([[Haskell]] is a notable example).


[[!redirects fixed-point combinator]]
[[!redirects fixed-point combinators]]
