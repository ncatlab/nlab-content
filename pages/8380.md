
+-- {: .rightHandSide}
+-- {: .toc .clickDown tabindex="0"}
### Context
#### Type theory
+-- {: .hide}
[[!include type theory - contents]]
=--
=--
=--

#Contents#
* table of contents
{:toc}

## Idea

In [[computer science]], a _monad_  is a map that 

* sends every [[type]] $X$ of some [[programming language]] to a new type $T(X)$ (called the "type of $T$-computations with values in $X$");

* equipped with a rule for composing two [[functions]] of the form $f : X \to T(Y)$ (called _[[Kleisli functions]]_) and $g : Y \to T(Z)$ to a function $bind(f,g) : X \to T (Z)$ (their [[Kleisli composition]]);

* in a way that is [[associativity law|associative]] in the evident sense and [[unit law|unital]] with respect to a given unit function called $return_X : X \to T(X)$, to be thought of as taking a value to the trivial computation that simply returns that value.

### For imperative programs in functional programming

Monads provide one way to "embed [[imperative programming]] in 
[[functional programming]]", and are used that way notably in the 
[[programming language]] [[Haskell]]. (But monads, as well as [[comonads]] and related structures) exist much more generally in programming languages, an exposition is in ([Harper](#Harper))). 

For instance when the monad $T(-)$ forms [[product types]] $T(X) \coloneqq X \times Q$ with some fixed type $Q$, then a [[Kleisli function]] $f : X \to Y \times Q$ may be thought of as a function $X \to Y$ that produces a "side effect" output of type $Q$. If the software is designed such that all values written to $Q$ appear on the user's sceen, then this is a way to encode _input/output_ in [[functional programming]] (see the [[IO monad]] below). 

But monads have plenty of further uses. They are as ubiquituous (sometimes in disguise) in [[computer science]] as [[monad|monads in the sense of category theory]] are (sometimes in disguise) in [[category theory]]. This is no coincidence, see _[Relation to monads in category theory](#RelationToMonadsInCategoryTheory)_ below.

### Relation to monads in category theory
 {#RelationToMonadsInCategoryTheory}

In [[computer science]], a programming language may be formalised or studied by means of a [[category]], called the _[[syntactic category]]_ $\mathcal{C}$, whose 

* [[objects]] $X \in \mathcal{C}$ are the [[types]] of the language, 

* [[morphisms]] $X \to Y$ are the [[terms]] or [[programs]] (or an [[equivalence class]] of such) that takes a value of [[type]] $Y$ as input and returns a value of type $Y$.  

This point of view (see _[[computational trinitarianism]]_) is particularly useful when studying purely [[functional programming languages]].

Under this [[relation between type theory and category theory]] monads on the type system in the sense of computer science are [[monad|monads in the sense of category theory]], being certain [[endofunctors]] 

$$
  T : \mathcal{C} \to \mathcal{C}
$$

on the [[syntactic category]]. This [[functor]]

1. sends each [[type]], hence [[object]] $X \in \mathcal{C}$ to another object $T(X)$;

1. the unit [[natural transformation]] $\epsilon : Id_{\mathcal{C}} \Rightarrow T$ of the [[monad]] $T$ provides for each type $X$ a compnent morphism [[morphism]] $return_X : X \to T(X)$;

1. the _composition_ [[natural transformation]] $\mu : T \circ T \Rightarro T$ of the monad provides for each object $X$ a morpjhism $\mu_X : T(T(X)) \Rightarrow X$ whic induces the [[Kleisli composition]] by the standard formula 

  $$
    \begin{aligned}
    bind(f,g)
    &\coloneqq
    (Y \stackrel{g}{\to} T(Y)) \circ_{Kleisli} (X \stackrel{f}{\to} T(Y))
    \\
    & \coloneqq
    X \stackrel{f}{\to} T(Y)
    \stackrel{T(g)}{\to} T(T(Z))
    \stackrel{\mu(Z)}{\to}
    T Z
    \end{aligned}
    \,,
  $$

Here the morphism $T(g)$ in the middle of the last line makes use of the fact that $T(-)$ is indeed a [[functor]] and hence may also be applied to morphisms / functions between types. The last morphism $\mu(Z)$ is the one that implements the "$T$-computation".


The monads arising this way in computer science are usually required also to interact nicely with the structure of the programming language, as encoded in the structure of its syntactic category; in most cases, terms of the language will be allowed to take more than one input, so the category $\mathcal{C}$ will be at least [[monoidal category|monoidal]], and the corresponding kind of 'nice' interaction corresponds to the monad being a _[[strong monad]]_.



## Examples

* A number of monads are *definable* in terms of standard type-forming operations, such as the [[maybe monad]], the [[reader monad]], the [[writer monad]], and the [[state monad]].

* Other monads may be supplied "axiomatically" by the programming language, such as the [[IO monad]] in [[Haskell]].

* Equipping [[homotopy type theory]] (say implemented as a programming language concretely in [[Coq]] or [[Agda]]) with two axiomatic [[idempotent monads]], denoted $\sharp$ and $\Pi$, with some additional data and relations, turns it into _[[cohesive homotopy type theory]]_.

## References

The technical definition can be found in...

> ...where? There are many, many references of and expositions of monads in computer science. Somebody who knows a _good_ reference, please add it here. We may assume that the reader knows monads, and knows type systems. We need a reference that gives a crisp precise definition: "A monad in a typed functional programming language is ..."

Expositions are in

* [[Robert Harper]], _Of course ML Has Monads!_ (2011) ([web](http://existentialtype.wordpress.com/2011/05/01/of-course-ml-has-monads/))
 {#Harper}

The specification of monads in [[Haskell]] is at

* [The Haskell programming language](http://www.haskell.org/haskellwiki/Haskell), _[Monad laws](http://www.haskell.org/haskellwiki/Monad_laws)_

[[!redirects monads (in computer science)]]

[[!redirects monads (in programming theory)]]
[[!redirects monad (in programming theory)]]
