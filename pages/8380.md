
+-- {: .rightHandSide}
+-- {: .toc .clickDown tabindex="0"}
### Context
#### Type theory
+-- {: .hide}
[[!include type theory - contents]]
=--
=--
=--

# Contents
* table of contents
{: toc}

## Idea

In [[computer science]], a _monad_ describes a "notion of computation".  Formally, it is a map that 

* sends every [[type]] $X$ of some given [[programming language]] to a new type $T(X)$ (called the "type of $T$-computations with values in $X$");

* equipped with a rule for composing two [[functions]] of the form $f : X \to T(Y)$ (called _[[Kleisli functions]]_) and $g : Y \to T(Z)$ to a function $bind(f,g) : X \to T (Z)$ (their [[Kleisli composition]]);

* in a way that is [[associativity law|associative]] in the evident sense and [[unit law|unital]] with respect to a given unit function called $return_X : X \to T(X)$, to be thought of as taking a value to the trivial computation that simply returns that value.

This is essentially the same structure as a [[monad]] in [[category theory]], but presented differently; see below for the precise relationship.

### For imperative programs in functional programming

Monads provide one way to "embed [[imperative programming]] in 
[[functional programming]]", and are used that way notably in the 
[[programming language]] [[Haskell]]. (But monads, as well as [[comonads]] and related structures, exist much more generally in programming languages; an exposition is in ([Harper](#Harper))). 

For instance when the monad $T(-)$ forms [[product types]] $T(X) \coloneqq X \times Q$ with some fixed type $Q$ that carries the structure of a [[monoid]], then a [[Kleisli function]] $f : X \to Y \times Q$ may be thought of as a function $X \to Y$ that produces a "side effect" output of type $Q$.  The Kleisli composition of two functions $f \colon X \to Y \times Q$ and $g \colon Y \to Z \times Q$ then not only evaluates the two programs in sequence but also combines their $Q$-output using the monoid operation of $Q$; so if $f x = (y,q)$ and $g y = (z,q')$ then the final result of $bind(f,g)(x)$ will be $(z, q q')$.  For example, $Q$ might be the set of strings of characters, and the monoid operation that of concatenation of strings (i.e. $Q$ is the [[free monoid]] on the type of characters).  If the software is designed such that values of type $Q$ computed in this way appear on the user's scteen or are written to memory, then this is a way to encode _input/output_ in [[functional programming]] (see the [[IO monad]] below). 

But monads have plenty of further uses. They are as ubiquituous (sometimes in disguise) in [[computer science]] as [[monad|monads in the sense of category theory]] are (sometimes in disguise) in [[category theory]]. This is no coincidence, see _[Relation to monads in category theory](#RelationToMonadsInCategoryTheory)_ below.

### Relation to monads in category theory
 {#RelationToMonadsInCategoryTheory}

In [[computer science]], a programming language may be formalised or studied by means of a [[category]], called the _[[syntactic category]]_ $\mathcal{C}$, whose 

* [[objects]] $X \in \mathcal{C}$ are the [[types]] of the language, 

* [[morphisms]] $X \to Y$ are the [[terms]] or [[programs]] (or an [[equivalence class]] of such) that takes a value of [[type]] $X$ as input and returns a value of type $Y$.  

This point of view (see _[[computational trinitarianism]]_) is particularly useful when studying purely [[functional programming|functional programming languages]].

Under this [[relation between type theory and category theory]] monads on the type system in the sense of computer science are [[monad|monads in the sense of category theory]], being certain [[endofunctors]] 

$$
  T : \mathcal{C} \to \mathcal{C}
$$

on the [[syntactic category]]. This [[functor]]

1. sends each [[type]], hence [[object]] $X \in \mathcal{C}$ to another object $T(X)$;

1. the unit [[natural transformation]] $\epsilon : Id_{\mathcal{C}} \Rightarrow T$ of the [[monad]] $T$ provides for each type $X$ a component [[morphism]] $return_X : X \to T(X)$;

1. the _multiplication_ [[natural transformation]] $\mu : T \circ T \Rightarrow T$ of the monad provides for each object $X$ a morphism $\mu_X : T(T(X)) \Rightarrow X$ which induces the [[Kleisli composition]] by the formula

  $$
    \begin{aligned}
    bind(f,g)
    &\coloneqq
    (Y \stackrel{g}{\to} T(Y)) \circ_{Kleisli} (X \stackrel{f}{\to} T(Y))
    \\
    & \coloneqq
    X \stackrel{f}{\to} T(Y)
    \stackrel{T(g)}{\to} T(T(Z))
    \stackrel{\mu(Z)}{\to}
    T Z
    \end{aligned}
    \,,
  $$

Here the morphism $T(g)$ in the middle of the last line makes use of the fact that $T(-)$ is indeed a [[functor]] and hence may also be applied to morphisms / functions between types. The last morphism $\mu(Z)$ is the one that implements the "$T$-computation".


The monads arising this way in computer science are usually required also to interact nicely with the structure of the programming language, as encoded in the structure of its syntactic category; in most cases, terms of the language will be allowed to take more than one input, so the category $\mathcal{C}$ will be at least [[monoidal category|monoidal]], and the corresponding kind of 'nice' interaction corresponds to the monad's being a _[[strong monad]]_.



## Examples

* A number of monads are *definable* in terms of standard type-forming operations, such as the [[maybe monad]], the [[reader monad]], the [[writer monad]], and the [[state monad]].

* Other monads may be supplied "axiomatically" by the programming language, such as the [[IO monad]] in [[Haskell]].

* Equipping [[homotopy type theory]] (say implemented as a programming language concretely in [[Coq]] or [[Agda]]) with two axiomatic [[idempotent monads]], denoted $\sharp$ and $\Pi$, with some additional data and relations, turns it into _[[cohesive homotopy type theory]]_. See also _[[modal type theory]]_.

## Related concepts

Examples of (co)monads in [[type theory]] appear in 

* [[modal type theory]].

## References

The original reference for monads as 'notions of computation' is

* [[Eugenio Moggi]], _Notions of computation and monads_ Information And Computation, 93(1), 1991. ([pdf](http://www.disi.unige.it/person/MoggiE/ftp/ic91.pdf))

Expositions are in

* [[Robert Harper]], _Of course ML Has Monads!_ (2011) ([web](http://existentialtype.wordpress.com/2011/05/01/of-course-ml-has-monads/))
 {#Harper}

The specification of monads in [[Haskell]] is at

* [The Haskell programming language](http://www.haskell.org/haskellwiki/Haskell), _[Monad laws](http://www.haskell.org/haskellwiki/Monad_laws)_


[[!redirects monad (in computer science)]]
[[!redirects monads (in computer science)]]

[[!redirects monad (in programming theory)]]
[[!redirects monads (in programming theory)]]
