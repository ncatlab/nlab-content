
+-- {: .rightHandSide}
+-- {: .toc .clickDown tabindex="0"}
### Context
#### Type theory
+-- {: .hide}
[[!include type theory - contents]]
=--
=--
=--

#Contents#
* table of contents
{:toc}

## Idea

In [[computer science]], a programming language may be formalised or studied by means of a 'syntactic' [[category]], whose objects are the [[types]] of the language, and in which a [[morphism]] $A \to B$ is a [[term]] or program (or an equivalence class of such) that takes a value of type $A$ as input and returns a value of type $B$.  This point of view (see _[[computational trinitarianism]]_) is particularly useful when studying purely functional languages.

Monads provide one way to "embed [[imperative programming]] in 
[[functional programming]]", and are used that way notably in the 
[[programming language]] [[Haskell]]. But monads (as well as [[comonads]] and related structures) exist much more generally in programming languages. ([Harper](#Harper))

Specifically, a _monad_ $T$ is an operation that

1. sends each [[type]] $A$, thought of as the collection of _values_ of type $A$, to some new type $T(A)$, that of _computations_ of type $A$;

1. provides for each type $A$ a [[term]] of [[function type]] $return_A : A \to T(A)$, which takes a value to the trivial computation that simply returns that value;

1. provides a _composition rule_ that creates from a [[term]] $t : T(A)$ and a function $f : A \to T(B)$ a term $bind t \,\, f : T(B)$, which runs or evaluates the computation $t$ and passes the result to $f$;

all these being required to satisfy the [[monad|usual axioms]].

A monad in this sense is usually required also to interact nicely with the structure of the language, as encoded in the structure of its syntactic category; in most cases, terms of the language will be allowed to take more than one input, so the category derived from it will be at least [[monoidal category|monoidal]], and the corresponding kind of 'nice' interaction corresponds to the monad's being [[strong monad|strong]].

Under the identification of a programming language with a category $\mathcal{C}$, a monad as above is then a [[strong monad|(strong)]] [[monad|monad in the sense of category theory]], hence a [[functor]] $T : \mathcal{C} \to \mathcal{C}$ equipped with the structure of a [[monoid]] in endomorphisms:

* the $return$-term is the _unit_ of the monad;

* the $bind$-operation is [[Kleisli composition]], from which the usual _multiplication_ of the monad can be recovered.



## Examples

* A number of monads are *definable* in terms of standard type-forming operations, such as the [[maybe monad]], the [[reader monad]], the [[writer monad]], and the [[state monad]].

* Other monads may be supplied "axiomatically" by the programming language, such as the [[IO monad]] in [[Haskell]].

* Equipping [[homotopy type theory]] (say implemented as a programming language concretely in [[Coq]] or [[Agda]]) with two axiomatic [[idempotent monads]], denoted $\sharp$ and $\Pi$, with some additional data and relations, turns it into _[[cohesive homotopy type theory]]_.

## References

The technical definition can be found in...

> ...where? There are many, many references of and expositions of monads in computer science. Somebody who knows a _good_ reference, please add it here. We may assume that the reader knows monads, and knows type systems. We need a reference that gives a crisp precise definition: "A monad in a typed functional programming language is ..."

Expositions are in

* [[Robert Harper]], _Of course ML Has Monads!_ (2011) ([web](http://existentialtype.wordpress.com/2011/05/01/of-course-ml-has-monads/))
 {#Harper}

The specification of monads in [[Haskell]] is at

* [The Haskell programming language](http://www.haskell.org/haskellwiki/Haskell), _[Monad laws](http://www.haskell.org/haskellwiki/Monad_laws)_

[[!redirects monads (in computer science)]]

[[!redirects monads (in programming theory)]]
[[!redirects monad (in programming theory)]]
