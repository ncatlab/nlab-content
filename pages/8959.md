+-- {: .rightHandSide}
+-- {: .toc .clickDown tabindex="0"}
### Context
#### Type theory
+-- {: .hide}
[[!include type theory - contents]]
=--
#### Foundations
+-- {: .hide}
[[!include foundations - contents]]
=--
=--
=--

# The meaning explanation of type theory

* table of contents
{: toc}

## Idea

[[Per Martin-Löf]]'s **meaning explanation of type theory** is a way to motivate the rules of (usually [[extensional type theory|extensional]]) [[type theory]] based on the idea of *assigning* types to "computational objects" in a pre-existing semantics.  It can be regarded either as meta-mathematical 
or as "pre-mathematical".

## Definition

Suppose we have given some collection of computational objects which we call "terms", with an *untyped* notion of "reduction" or "computation".
We write $x\Rightarrow y$ to mean that $x$ computes or reduces to $y$ (in some number of steps).
We then define simultaneously the following [[judgments]], where $a,b,A$ are terms:

* $A$ is a type, often written $A\;type$.
* $a$ has type $A$, written $a:A$.
* $a$ and $b$ are equal terms of type $A$, written $a=b:A$.

The definition is by [[induction-recursion]].  We define the property "$A$ is a type" *inductively*, and simultaneously we define *recursively* two functions assigning to each type $A$ the collection of terms of type $A$ and the collection of pairs of equal terms of type $A$, respectively.  Moreover, each such collection may itself be defined inductively.

The clauses which we include in each case depend on what types we want to put into our type theory; in each case the base notion of untyped computation must include a corresponding structure.  Here are three paradigmatic examples.

### Natural numbers

Suppose that we have terms $N$, $0$, and $s(x)$, along with a recursor $rec(n,z_0,x r. z_s)$ such that
$$rec(0,z_0,x r.z_s) \Rightarrow z_0$$
and
$$rec(s(n),z_0,x r. z_s) \Rightarrow z_s[n/x,rec(n,z_0,x r.z_s)/r].$$
Then to explain the [[natural numbers type]], we include a clause in the inductive definition of "$A$ is a type" which says

* if $A\Rightarrow N$, then $A$ is a type.

The corresponding clause for elements is

* if $A\Rightarrow N$, then the collection of terms $a$ such that $a:A$ is defined inductively by the clauses:
  * if $a\Rightarrow 0$, then $a:A$.
  * if $a\Rightarrow s(b)$ and $b:A$, then $a:A$.

And for equality:

* if $A\Rightarrow N$, then the collection of pairs $a,b$ such that $a=b:A$ is defined inductively by the clauses:
  * if $a\Rightarrow 0$ and $b\Rightarrow 0$, then $a=b:A$.
  * if $a\Rightarrow s(a')$ and $b\Rightarrow s(b')$ and $a'=b':A$, then $a=b:A$.

### Function types

Suppose that we have a term constructor yielding "$A\to B$" for terms $A$ and $B$, and similarly $app(f,a)$ and $\lambda x.t$, such that
$$ app(\lambda x.t, a) \Rightarrow t[a/x]. $$
Then to explain the [[function type]], we include a clause in the inductive definition of "$A$ is a type" which says

* if $A$ is a type and $B$ is a type and $C\Rightarrow (A\to B)$, then $C$ is a type.

The clause for elements is:

* if $C\Rightarrow (A\to B)$ for types $A$ and $B$, and for any $a:A$ we have $app(f,a):B$, then $f:A\to B$.  In other words, the collection of elements of type $A\to B$ is the collection of terms $f$ such that for any $a:A$ we have $app(f,a):B$.

This is not an inductive definition as we had for the natural numbers; it is merely a simple definition.  On the other hand, we are now using the fact that the function mapping types to their collections of elements is recursively defined, since in order to make this definition, we must invoke it at $A$ and $B$.

For equality, of course we have:

* if $C\Rightarrow (A\to B)$ for types $A$ and $B$, and for any $a:A$ we have $app(f,a)=app(g,a):B$, then $f=g:A\to B$.

### Identity types

Suppose we have a term constructor yielding $Id_A(a,b)$ for terms $A,a,b$, and similarly $refl$.
Then to explain the [[identity type]], we add to the inductive definition of "$A$ is a type" the clause

* If $A$ is a type and $a:A$ and $b:A$, then $Id_A(a,b)$ is a type.

Here we are finally using the fact that typehood and elements are defined by induction-recursion: this clause in the *inductive* definition of typehood must refer to the value of the *recursive* elementhood function at some smaller type.

The clause for elements is:

* If $A$ is a type and $a:A$, $b:A$ and $a=b:A$ and $p\Rightarrow refl$, then $p:Id_A(a,b)$.  In other words, the collection of elements of type $Id_A(a,b)$ contains, if if $a=b:A$, precisely those terms which reduce to $refl$.

Here we use not only the fact that elementhood is recursively defined, but that it is defined by mutual recursion with equality.  The clause for equality is:

* If $A$ is a type and $a:A$, $b:A$ and $a=b:A$, and $p\Rightarrow refl$ and $q\Rightarrow refl$, then $p=q:Id_A(a,b)$.

Because we have deliberately only put $refl$ (and terms reducing to it) into the identity type, we can only motivate or explain [[extensional type theory]] in this way.  There are proposals for ways to expand the meaning explanation to deal with [[intensional type theory]].

### The rules of type theory

The claim is that by inspecting these definitions, one can arrive at the formal rules of [[type theory]] for manipulating judgments such as "$A$ is a type", "$a:A$", and "$a=b:A$", which no longer refer to any given notion of computation.  However, Martin-Löf famously wrote

> ...there are ... certain limits to what verbal explanations can do when it comes to justifying axioms and rules of inference.  In the end, everybody must understand for himself.


## References

* [[Per Martin-Löf]], "Constructive mathematics and computer programming"

[[!redirects meaning explanation]]
[[!redirects the meaning explanation]]
[[!redirects meaning explanation of type theory]]
[[!redirects the meaning explanation of type theory]]
