
+-- {: .rightHandSide}
+-- {: .toc .clickDown tabindex="0"}
### Context
#### Type theory
+-- {: .hide}
[[!include type theory - contents]]
=--
=--
=--

# $\eta$-reduction and expansion
* table of contents
{: toc}

## Idea

In [[type theory]], $\eta$-reduction/expansion is a process of "computation" which is "dual" to [[beta-reduction]].

Whereas $\beta$-reduction tells us how to simplify a term that involves an *eliminator* applied to a *constructor*, $\eta$-reduction tells us how to simplify a term that involves a *constructor* applied to an *eliminator*.

In contrast to beta-reduction, whose "directionality" is universally agreed upon, the directionality of the eta relationship is not always the same.  Sometimes one may talk about eta-**reduction**, which simplifies a constructor--eliminator pair by removing it, but we may also talk about eta-**expansion**, which makes a term more complicated by introducing a constructor--eliminator pair.  (The difference is most striking with respect to the [[trivial type]], where $\eta$-expansion is actually a simplification and $\eta$-reduction is ill-defined.)  The [[equivalence relation]] generated by $\eta$-reduction/expansion is called **$\eta$-equivalence**.


## Examples

### For function types

The most common example is for a [[function type]] $A \to B$.

In this case, the constructor of $A \to B$ is a *$\lambda$-expression*: given a term $b$ of type $B$ containing a free variable $x$ of type $A$, then $\lambda x.b$ is a term of type $A \to B$.

The eliminator of $A \to B$ says that given a term $f$ of type $A \to B$ and a term $a$ of type $A$, we can *apply* $f$ to $a$ to obtain a term $f(a)$ of type $B$.

An $eta$-redex (a term that can be reduced by $\eta$-reduction) is then of the form $\lambda x.\, f(x)$ -- the constructor (lambda expression) applied to the eliminator (application).  Eta reduction reduces such a redex to the term $f$.

Conversely, $\eta$-expansion expands any bare function term $f$ to the form $\lambda x.\, f(x)$.  If $\eta$-expansion is applied again to this, we get $\lambda x.\, (\lambda y.\, f(y))(x)$, but $\beta$-reduction returns this to $\lambda x.\, f(x)$; therefore, this last form is considered to be fully $\eta$-expanded.  In general, the rule when applying $\eta$-expansion is to use it only when the result is not a $\beta$-redex.


### For product types

Although function types are the most publicized notion of $\eta$-reduction, basically all types in type theory can have a form of it.  For instance, in the negative presentation of a [[product type]] $A \times B$, the constructor is an ordered pair $(a,b)\colon A\times B$, while the eliminators are projections $\pi_1$ and $\pi_2$ which yield elements of $A$ or $B$.

The $\eta$ rule then says that for a term $p\colon A\times B$, the term $(\pi_1 p, \pi_2 p)$ --- the constructor applied to the eliminators --- is equivalent to $p$ itself.  (Again, we do not repeat the $\eta$-expansion, as this would produce a $\beta$-redex.)


## Implementation

Eta-reduction/expansion is not as well-behaved formally as beta-reduction, and its introduction can make computational equality undecidable.  For this reason and others, it is not always implemented in computer proof assistants.

[[Coq]] versions 8.3 and prior do not implement eta equivalence (definitionally), but versions 8.4 and higher do.

When $\eta$-equivalence is not an implemented as a direct identity, it may be derived from a defined (coarser than identity) equality.  For example, if $f =_{A \to B} g$ is defined to mean $\forall x.\, f(x) =_B g(x)$ (where $=_B$ is assumed to have been previously defined) and $(\lambda x.\, b)(a)$ is taken to be identical to $b[a/x]$ (implementing $\beta$-reduction), then $f$ and $\lambda x.\, f(x)$ are provably equal even if not identical.


## Related concepts

* [[lambda-calculus]]

* [[beta-reduction]]


[[!redirects eta reduction]]
[[!redirects eta-reduction]]
[[!redirects ∞-reduction]]

[[!redirects eta expansion]]
[[!redirects eta-expansion]]
[[!redirects ∞-expansion]]

[[!redirects eta equivalent]]
[[!redirects eta-equivalent]]
[[!redirects ∞-equivalent]]
[[!redirects eta equivalence]]
[[!redirects eta-equivalence]]
[[!redirects ∞-equivalence]]
