
+-- {: .rightHandSide}
+-- {: .toc .clickDown tabindex="0"}
### Context
#### Type theory
+-- {: .hide}
[[!include type theory - contents]]
=--
=--
=--

# $\eta$-conversion
* table of contents
{: toc}

## Idea

In [[type theory]], $\eta$-conversion is a process of "computation" which is "dual" to [[beta-conversion]].

Whereas $\beta$-reduction tells us how to simplify a term that involves an *eliminator* applied to a *constructor*, $\eta$-reduction tells us how to simplify a term that involves a *constructor* applied to an *eliminator*.

In contrast to $\beta$-reduction, whose "directionality" is universally agreed upon, the directionality of $\eta$-conversion is not always the same.  Sometimes one may talk about $\eta$-**reduction**, which (usually) simplifies a constructor--eliminator pair by removing it, but we may also talk about $\eta$-**expansion**, which (usually) makes a term more complicated by introducing a constructor--eliminator pair.  Although one might expect that of course we always want to use reduction to simplify, it is possible to put bounds on $\eta$-expansion, and $\eta$-reduction is ill-defined for the [[unit type]] (the exception prompting 'usually' above).

However, from a category-theoretic POV, it is more natural to consider $\eta$ to be an expansion, which paired with $\beta$ as a reduction can be used as a syntax for a [[lax 2-adjunction]] [(Seely)](#Seely).

The [[equivalence relation]] generated by $\eta$-reduction/expansion is called $\eta$-**equivalence**, and the whole collection of processes is called $\eta$-**conversion**.


## Examples

### For function types

The most common example is for a [[function type]] $A \to B$.

In this case, the constructor of $A \to B$ is a *$\lambda$-expression*: given a term $b$ of type $B$ containing a free variable $x$ of type $A$, then $\lambda x.b$ is a term of type $A \to B$.

The eliminator of $A \to B$ says that given a term $f$ of type $A \to B$ and a term $a$ of type $A$, we can *apply* $f$ to $a$ to obtain a term $f(a)$ of type $B$.

An $eta$-[[redex]] (a term that can be reduced by $\eta$-reduction) is then of the form $\lambda x.\, f(x)$ -- the constructor (lambda expression) applied to the eliminator (application).  Eta reduction reduces such a redex to the term $f$.

Conversely, $\eta$-expansion expands any bare function term $f$ to the form $\lambda x.\, f(x)$.  If $\eta$-expansion is applied again to this, we get $\lambda x.\, (\lambda y.\, f(y))(x)$, but $\beta$-reduction returns this to $\lambda x.\, f(x)$; therefore, this last form is considered to be fully $\eta$-expanded.  In general, the rule when applying $\eta$-expansion is to use it only when the result is not a $\beta$-redex.


### For product types

Although function types are the most publicized notion of $\eta$-reduction, basically all types in type theory can have a form of it.  For instance, in the [[negative type|negative]] presentation of a [[product type]] $A \times B$, the constructor is an [[ordered pair]] $(a,b)\colon A\times B$, while the eliminators are projections $\pi_1$ and $\pi_2$ which yield elements of $A$ or $B$.

The $\eta$-expansion rule then says that for a term $p\colon A\times B$, the term $(\pi_1 p, \pi_2 p)$ --- the constructor applied to the eliminators --- is equivalent to $p$ itself.  (Again, we do not repeat the $\eta$-expansion, as this would produce a $\beta$-redex.)  If we use $\eta$-reduction instead, then we simplify any subterm of the form $(\pi_1 p, \pi_2 p)$ to $p$ (and leave anything not of that form alone).


### For unit types

Above we did a product type with two factors, although it\'s easy to generalise to any [[natural number]] of factors.  The case with zero factors is known as the [[unit type]], and $\eta$-conversion behaves a bit oddly there; let us examine it.

In the [[negative type|negative]] presentation of the unit type $1$, the constructor is an [[empty list]] $()\colon 1$, while there are no eliminators.  The $\eta$-expansion rule then says that any term $p\colon 1$ is equivalent to the term $()$ --- the constructor applied to no eliminators.  In this case, if we repeat the $\eta$-expansion, this does not produce a $\beta$-redex (indeed, there is *no* $\beta$-reduction for the unit type), but simply makes no change.  If we try to apply $\eta$-reduction to $()$, then this is ill-defined; we could 'simplify' this to *any* term $p\colon 1$ that we might be able to construct.

The [[positive type|positive]] presentation of the unit type does have a well-defined $\eta$-reduction, however; see [[unit type]].


## Implementation

Eta-reduction/expansion is not as well-behaved formally as beta-reduction, and its introduction can make computational equality undecidable.  For this reason and others, it is not always implemented in computer proof assistants.

[[Coq]] versions 8.3 and prior do not implement $\eta$-equivalence (definitionally), but versions 8.4 and higher do implement it for [[dependent product types]] (which include [[function types]]).  Even in Coq v8.4, $\eta$-equivalence is not implemented for other types, such as inductive and coinductive types.  This is a good thing for [[homotopy type theory]], since $\eta$-equivalence for [[identity types]] forces us into [[set-level type theory]].

When $\eta$-equivalence is not an implemented as a direct identity, it may be derived for a defined (coarser than identity) equality.  For example, if $f =_{A \to B} g$ is defined to mean $\forall x.\, f(x) =_B g(x)$ (where $=_B$ is assumed to have been previously defined) and $(\lambda x.\, b)(a)$ is taken to be identical to $b[a/x]$ (implementing $\beta$-reduction), then $f$ and $\lambda x.\, f(x)$ are provably equal even if not identical.  Thus, eta-equivalence for function types follows from [[function extensionality]] (relative to any appropriate notion of equality).

Similarly, if "equality" refers to a Martin-L&#246;f [[identity type]] in [[dependent type theory]], then a suitable form of $\eta$-equivalence is provable for inductively defined types (with $\beta$-reduction and a dependent eliminator).  This includes the identity types themselves, but this form of $\eta$-equivalence does not imply the identity types are valued in propositions because the identity type itself must be incorporated in stating the equivalence.  See the next section.

## Propositional $\eta$-conversion
 {#Propositional}

In [[dependent type theory]], an important role is played by *propositional $\eta$-conversions* which "compute to identities" along constructors.  For example, consider binary products with $\beta$-reduction, but not (definitional) $\eta$-conversion.  We say that **$\eta$-conversion holds propositionally** if

1. For any $p\colon A\times B$ we have a term $\eta_p \colon Id_{A\times B}(p, (\pi_1 p, \pi_2 p))$, and

2. For $a\colon A$ and $b\colon B$ we have a [[definitional equality]] $\eta_{(a,b)} = 1_{(a,b)}$ (where $1_{(a,b)}$ denotes the reflexivity constructor of the [[identity type]]).

Similar definitions apply for any other type.

The reason this notion is important is that it is "equivalent" to the ability to extend the eliminator of non-dependent type theory to a *dependent* eliminator, where the type being eliminated into is dependent on the type under consideration.

For instance, in the case of the binary product, suppose that $\eta$-conversion holds propositionally as above, and that we have a dependent type $z\colon A\times B \vdash C(z)\colon Type$ along with a term $x\colon A, y\colon B \vdash c(x,y) \colon C((x,y))$ defined over the constructor.  Then for any $p\colon A\times B$ we can "transport" along $\eta_p$ to obtain a term defined over $p$, yielding the dependent eliminator.  The rule $\eta_{(a,b)} = 1_{(a,b)}$ ensures that this dependent eliminator satisfies the appropriate $\beta$-reduction rule.

Conversely, if we have a dependent eliminator, then $\eta_p$ can be defined by eliminating into the dependent type $z\colon A\times B \vdash id_{A\times B}(z,(\pi_1 z, \pi_2 z))$, since when $z$ is $(x,y)$ we have $1_{(x,y)}$ inhabiting this type.

Note that this "equivalence" is itself only "propositional", however; if we go back and forth, we should not expect to get literally the same dependent eliminator or propositional $\eta$ term, only a propositionally-equal one.

The same principle applies to other types, particularly [[dependent sum types]] and [[dependent product types]]/[[function types]] (although the latter are a bit trickier).


## Related concepts

* [[lambda-calculus]]

* [[beta-reduction]]

## References ##


* Seely, _Modelling computations: a 2-categorical framework_, [pdf](http://www.math.mcgill.ca/~rags/WkAdj/LICS.pdf)
 {#Seely}


[[!redirects eta conversion]]
[[!redirects eta-conversion]]
[[!redirects ∞-conversion]]

[[!redirects eta reduction]]
[[!redirects eta-reduction]]
[[!redirects ∞-reduction]]

[[!redirects eta expansion]]
[[!redirects eta-expansion]]
[[!redirects ∞-expansion]]

[[!redirects eta rule]]
[[!redirects eta-rule]]
[[!redirects ∞-rule]]

[[!redirects eta equivalent]]
[[!redirects eta-equivalent]]
[[!redirects ∞-equivalent]]
[[!redirects eta equivalence]]
[[!redirects eta-equivalence]]
[[!redirects ∞-equivalence]]

[[!redirects η-expansion]]
[[!redirects η-reduction]]
[[!redirects η-conversion]]
